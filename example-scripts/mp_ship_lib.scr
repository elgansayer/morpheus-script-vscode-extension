//-------------------------------------
main:
//-------------------------------------
	level.gametype = int( getcvar( g_gametype ) )
	// set scoreboard messages
	if( level.gametype == 4 )
	{
		setcvar "g_obj_alliedtext1" ( loc_convert_string "Disable the" )
		setcvar "g_obj_alliedtext2" ( loc_convert_string "Engine Room" )
		setcvar "g_obj_alliedtext3" ""

		setcvar "g_obj_axistext1" ( loc_convert_string "Protect the" )
		setcvar "g_obj_axistext2" ( loc_convert_string "Engine Room" )
		setcvar "g_obj_axistext3" ""
	}
	else
	{
		setcvar "g_obj_alliedtext1" ( loc_convert_string "Stuckguter" )
		setcvar "g_obj_alliedtext2" ""
		setcvar "g_obj_alliedtext3" ""
		setcvar "g_obj_axistext1" ""
		setcvar "g_obj_axistext2" ""
		setcvar "g_obj_axistext3" ""
	}
	setcvar "g_scoreboardpic" "textures/mohmenu/dmloading/mp_ship_lib"
	
	if (level.gametype == 4) 
	{
		$alliesjailswitch remove		
		$axisjailswitch remove
		$axisjaildoor remove
		$alliesjaildoor remove
	}
/*	
	setcvar "g_obj_alliedtext1" "Stuckguter"	
	setcvar "g_obj_alliedtext2" ""
	setcvar "g_obj_alliedtext3" ""
	setcvar "g_obj_alliedtext4" ""
	setcvar "g_obj_alliedtext5" ""
	
	setcvar "g_obj_axistext1" ""
	setcvar "g_obj_axistext2" ""
	setcvar "g_obj_axistext3" ""
	setcvar "g_obj_axistext4" ""
	setcvar "g_obj_axistext5" ""
*/

	level.dmroundlimit = 5   // round time limit in minutes
	//if(level.gametype == 6)
		// call additional stuff for playing this map round based is needed
	waitthread global/lib_dm.scr::liberation_init

	exec global/DMprecache.scr
	level.mp_boat_level = 1
	exec global/MP_Boat_level_weather.scr
	
	///////////////////////
	level waittill prespawn
	///////////////////////
	
	exec global/door_locked.scr
	exec global/dm_ai.scr

	if($red_corona)
		thread Red_Coronas

	level.music="MP_Anzio"
	level.script = maps/lib/mp_ship_lib.scr

	////////////////////
	level waittill spawn
	////////////////////
	thread ShipTilt
	thread BoatTilt
	thread CenterpieceTilt

	if (level.gametype > 2) 
	{
		/////////////////////////
		level waittill roundstart
		/////////////////////////
	}

	if (level.gametype == 4) 
	{
		waitthread ObjectiveMode
	}

	if (level.gametype == 6) 
	{
		// obj#, status, text, location
		// status -- 1) don't draw, 2) in progress, 3) completed		
		addobjective 1 1 "Free teammates from the jail" $alliesjailswitch.origin		
		addobjective 2 1 "Free teammates from the jail" $axisjailswitch.origin

		setcurrentobjective 1 allies
		setcurrentobjective 2 axis

		//Setup our jail break triggers
		$axisjailtrigger thread AxisJailTrigger
		$alliesjailtrigger thread AlliesJailTrigger
	}



//	level.rain_speed = "32"
//	level.rain_speed_vary = "16"
//	level.rain_length = "2"
//	level.rain_width = "1"
//	level.rain_density = ".2"
//	level.rain_slant = "250"
//	level.rain_min_dist = "1800"
//	level.rain_numshaders = 12
//	level.rain_shader = "textures/rain"
End


// -------------------------------------------------------------------------------------
AxisJailTrigger:
// -------------------------------------------------------------------------------------
		
	self waittill trigger	

	//set the player using the jail switch trigger
	local.player = parm.other

	//flip the switch first
	if( local.player.dmteam == axis )
	{
		waitthread DoAxisSwitch

		thread global/lib_dm.scr::axisjaildooruse local.player

		wait 12

		waitthread DoAxisSwitch
	}

	$axisjailtrigger thread AxisJailTrigger

	end

// -------------------------------------------------------------------------------------
AlliesJailTrigger:
// -------------------------------------------------------------------------------------

	self waittill trigger

	local.player = parm.other
	
	//flip the switch first
	if( local.player.dmteam == allies )
	{
		waitthread DoAlliesSwitch

		thread global/lib_dm.scr::alliesjaildooruse local.player

		wait 12

		waitthread DoAlliesSwitch
	}

	$alliesjailtrigger thread AlliesJailTrigger

	end

// -------------------------------------------------------------------------------------
DoAxisSwitch:
// -------------------------------------------------------------------------------------
		
	if( level.bAxisSwitchDown == 0 )
	{			
		$axisjailswitch anim turnoff
		$axisjailswitch waittill animdone
		level.bAxisSwitchDown = 1
	}
	else
	{			
		
		$axisjailswitch anim turnon
		$axisjailswitch waittill animdone
		level.bAxisSwitchDown = 0
	}	


	end

// -------------------------------------------------------------------------------------
DoAlliesSwitch:
// -------------------------------------------------------------------------------------

	if( level.bAlliesSwitchDown == 0 )
	{			
		$alliesjailswitch anim turnoff
		$alliesjailswitch waittill animdone
		level.bAlliesSwitchDown = 1		
	}
	else
	{			
		$alliesjailswitch anim turnon
		$alliesjailswitch waittill animdone
		level.bAlliesSwitchDown = 0		
	}	


end

//------------------------------------------------------------------
ShipTilt:

	local.bail = getcvar(g_no_seasick)
	if ( local.bail == "1" )
	{
		end
	}

	while(!$player[1])
		waitframe
	level.maxTilt = 2.5 
	level.oldMaxTilt = 2.5
	level.dampening = 1
	local.viewangles = (0 0 0)
	local.viewangles[2] = level.maxTilt
	for(local.i = 1; local.i <= $player.size; local.i++)
		$player[local.i].viewangles = local.viewangles
	local.velocity = -1
	local.constant = -.0005 // -0.002
	
	while (1)
	{
//		for(local.i = 1; local.i <= $player.size; local.i++)
//			$player[local.i] iprint ("viewpos: " + $player[local.i].viewangles)
//		iprintln ("LASTVEL: " + local.velocity)
//		iprintln ("VEL: " + local.velocity)
		if (local.viewangles[2] > level.maxTilt && local.velocity > 0)
		{
			local.velocity = 0
		}
		else if (local.viewangles[2] < -level.maxTilt && local.velocity < 0)
		{
			local.velocity = 0
		}
	
		local.velocity += local.constant * local.viewangles[2]
/*
		for(local.i = 1; local.i <= 3; local.i++)
		{
			local.targetname =	("boat_" + local.i )
			local.angles = $(local.targetname).angles
			local.angles[2] += local.velocity
			$(local.targetname).angles = local.angles
		}
*/
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			local.viewangles = $player[local.i].viewangles
			local.viewangles[2] += local.velocity
			$player[local.i].viewangles =  local.viewangles
		}
		waitframe
	}

	// Reset the players view
	local.viewangles = $player.viewangles
	local.viewangles[2] = 0
	$player.viewangles = local.viewangles

End

//------------------------------------------------------------------
BoatTilt:

	while(!$player[1])
		waitframe
	local.maxTiltz = 8.5
	local.amt_z = 2.0
	local.amt_x = 0.5
	local.maxTiltx = 4.5 
		
	for(local.i = 1; local.i <= 4; local.i++)
		{
			local.targetname =	("boat_" + local.i )
			local.myangles = $(local.targetname).angles
			local.myorigin = $(local.targetname).origin
			local.mymodel = $(local.targetname).model
			$(local.targetname) delete
			waitframe
			local.coolboat = spawn script_object "model" local.mymodel "origin" local.myorigin "angles" local.myangles
			local.coolboat targetname local.targetname
			local.coolboat notsolid
			$(local.targetname) rotateZ local.amt_z
//			$(local.targetname) rotateX local.amt_x
		}
	local.velocity = -1
	local.constant = -.0005 // -0.002

	while (1)
	{
//		iprintln ( "angles: z: " + $boat_1.angles[2] + " x: " + $boat_1.angles[0])
		for(local.i = 1; local.i <= 4; local.i++)
		{
			local.targetname =	("boat_" + local.i )
//			iprintln (" " + local.targetname + ": angles = " +  $(local.targetname).angles)
			
			if ($(local.targetname).angles[2] >= local.maxTiltz &&
				$(local.targetname).angles[2] < ((360 - local.maxTiltz) - 1) )
			{
//				iprintln ("+z")
				$(local.targetname) rotateZ -local.amt_z
			}
			else if ($(local.targetname).angles[2] < (360 - local.maxTiltz) &&
				$(local.targetname).angles[2] > (local.maxTiltz + 1 ))
			{
//				iprintln ("-z")
				$(local.targetname) rotateZ local.amt_z
			}
			
/*
			if ($(local.targetname).angles[1] >= local.maxTiltx &&
				$(local.targetname).angles[1] < ((local.maxTiltx) - 1) )
			{
				iprintln ("+x")
				$(local.targetname) rotateX -local.amt_x
			}
			else if ($(local.targetname).angles[1] < (360 - local.maxTiltx) &&
				$(local.targetname).angles[1] > (local.maxTiltx + 1 ))
			{
				iprintln ("-x")
				$(local.targetname) rotateX local.amt_x
			}
*/		
		}
		waitframe

	}
End

CenterpieceTilt:
	local.maxTiltz = 2.5
	local.maxTiltx = 1.47 

	local.constant = -.003 // -0.002
	local.constantX = -0.0022
	local.velocity = -0.4
	local.velocityX = -0.33


	wait .7

	local.angles = $(local.targetname).angles
	local.angles[2] += 4.5
	local.angles[0] += 0.5
	$centerpiece angles local.angles

	while (1)
	{
//		iprintln ("viewpos: " + $centerpiece.angles)
//		iprintln ("VEL: " + local.velocity)

		local.tmp = $centerpiece.angles[2]

		if ( local.tmp > 180 )
			local.tmp -= 360

		if (local.tmp > local.maxTiltz && local.velocity > 0)
		{
			local.velocity = 0
		}
		else if (local.tmp < -local.maxTiltz && local.velocity < 0)
		{
			local.velocity = 0
		}
	
		local.velocity += local.constant * local.tmp

		local.tmp = $centerpiece.angles[0]

		if ( local.tmp > 180 )
			local.tmp -= 360

		if (local.tmp > local.maxTiltx && local.velocityX > 0)
		{
			local.velocityX = 0
		}
		else if (local.tmp < -local.maxTiltx && local.velocityX < 0)
		{
			local.velocityX = 0
		}
	
		local.velocityX += local.constantX * local.tmp

		$centerpiece rotateZ (local.velocity  * 20 )
		$centerpiece rotateX (local.velocityX * 20 )

		//local.viewangles = $centerpiece.angles
		//local.viewangles[2] += local.velocity
		//local.viewangles[0] += local.velocityX
		//$centerpiece angles local.viewangles
		
		waitframe
	}

End


// used to make the coronas blink, starts thread on each one of Flicker
Red_Coronas:
	for(local.i = 1; local.i <= $red_corona.size; local.i++)
		$red_corona[local.i] thread Flicker
End

Flicker:
	while (1)
	{
		self show
		local.number = randomfloat(3) + 1
		wait local.number
		self hide
		wait randomfloat(2)
		waitframe
	}
End

// Created Objective Mode
ObjectiveMode:
	
		local.bomborigin = (808 -612 -266)
		level.defusing_team = "axis" // allies
		level.planting_team = "allies"  // axis
		level.bombs_to_plant = 1
		level.bomb_damage = 600
		level.bomb_explosion_radius = 1024

		level.bomb_defuse_time = 60 //tenths of a second
		level.bomb_set_time = 50  //tenths of a second
		level.bomb_explosion_radius = 1054  //quake units
		level.bomb_use_distance = 128 //quake units
		level.bomb_damage = 200
		level.bombusefov = 30

		level.subtitleX = 100
		level.subtitleY = 50
		level.allieswin = 0
		// set the parameters for this round/wave based match
		level.clockside = axis // set to axis, allies, kills, or draw
		
		spawn script_model "targetname" "bomb1" "model" "items/pulse_explosive.tik" "origin" local.bomborigin
		local.crate = spawn script_model "targetname" "fakecrate" "origin" (808 -612 -296)
		
		wait 1.0
		$bomb1.trigger_name = spawn trigger_use "origin" $bomb1.origin targetname "Bomb1Trigger"
		$bomb1.explosion_fx = "fx/fx_flak88_explosion.tik"
		$bomb1.explosion_sound = "explode_aagun"
		waitframe
		$bomb1.angle = 90
		$bomb1.trigger_name setsize ( -40 -40 -40) (40 40 40)
		$bomb1 thread bomb_thinker
 

	  	thread allied_win_bomb
		thread axis_win_timer

		addobjective 1 1 "" $bomb1.origin
		setcurrentobjective 1
End

//*** --------------------------------------------
//*** Special effects macro
//*** --------------------------------------------

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp notsolid
	local.temp.origin = self.origin
	local.temp anim start
	local.temp playsound explode_truck1
	local.temp notsolid
	earthquake .5 2 1 0
	wait 5
	local.temp remove
end


//*** --------------------------------------------
//*** Explode all the crates near the bomb
//*** --------------------------------------------

explodeCrate:
	local.wait = 0.1 + randomfloat(0.6)
	wait local.wait
	self thread spawn_fx models/fx/fx_tank_explosion.tik
	wait 0.5
	self thread spawn_fx models/emitters/tehao_explosionDust.tik
end


//*** --------------------------------------------
//*** Wait for a bomb to go off
//*** --------------------------------------------

bomb_exploded local.bomb local.crates:
	while (local.bomb)
		wait .1

 	level.axiswin = 1

	local.crates waitthread explodeCrate

	teamwin allies
end

//*** --------------------------------------------
//*** "Axis Victory"
//*** --------------------------------------------
AxisVictory:
   	while (level.axiswin != 1) 
		wait 0.1

	teamwin axis

end

allied_win_bomb:

	level waittill allieswin

end

//*** --------------------------------------------
//*** "Allied Victory"
//*** --------------------------------------------

axis_win_timer:

	level waittill axiswin

end



//*** --------------------------------------------
//*** Bomb Code
//*** --------------------------------------------
bomb_thinker:
	level.bomb_defuse_time = 20 //tenths of a second
	level.bomb_set_time = 50  //tenths of a second, 50
	level.bomb_tick_time = 15  //seconds, 15
	level.bomb_explosion_radius = 500  //quake units
	level.bomb_use_distance = 128 //quake units
	level.bomb_damage = 200000
	level.bombusefov = 30

	level.subtitleX = 100
	level.subtitleY = 50
	
	self.live = 0

	if (self.target != NIL && self.target != NULL && $(self.target) != NULL)
	{
		self.target.collisionent = self.target.target
		self.target notsolid
	}

	thread bomb_waittill_set
end

bomb_waittill_set:
	self model items/pulse_explosive.tik
	while ( $(self.trigger_name) )
	{
		self.trigger_name waittill trigger
		local.player = parm.other

	        if (local.player.dmteam != level.planting_team) 
		{
			local.player iprint ( loc_convert_string "You are the wrong team to plant a bomb here!" )
			goto bomb_waittill_set
		}

		local.counter = 0
		while ( (Isalive local.player) && 
				(local.player cansee self level.bombusefov level.bomb_use_distance) && 
				(local.player.useheld == 1) && self.live == 0 )
		{
			if (local.counter == 0)
				local.player stopwatch (level.bomb_set_time * .1)
				
			local.counter++
			wait 0.1

			if (local.counter >= level.bomb_set_time)
			{
				iprintlnbold ( loc_convert_string "The Allies have Planted a Bomb!" )
				if (level.planting_team == "allies")
					self playsound dfr_objective_o
				else
					self playsound den_objective_o

				thread bomb_waittill_defuse
				thread bomb_waittill_explode

				self.live = 1
				level.bombs_planted ++
				end
			}
		}
		if (local.counter > 0)
			local.player stopwatch 0
	}
end


bomb_waittill_defuse:
	while ( $(self.trigger_name) )
	{
		self.trigger_name waittill trigger

		local.player = parm.other
	
		if (local.player.dmteam != level.defusing_team)
		{      
			local.player iprint ( loc_convert_string "You're on the wrong team to defuse this bomb!" )
			goto bomb_waittill_defuse
		}
	
		local.counter = 0
		while ( (Isalive local.player) && 
				(local.player cansee self level.bombusefov level.bomb_use_distance) && 
				(local.player.useheld == 1) && self.live == 1 )
		{
			if (local.counter == 0)
				local.player stopwatch (level.bomb_defuse_time * .1)
			
			local.counter++
			wait 0.1

			if (local.counter >= level.bomb_defuse_time)
			{
				iprintlnbold ( loc_convert_string "The Axis have Defused a Bomb!" )
				if (level.defusing_team == "axis")
					self playsound dfr_diffused_d
				else
					self playsound den_diffused_d
				thread bomb_waittill_set //start first thread again
				self.live = 0
				level.bombs_planted --
				end
			}
		}
		if (local.counter > 0)
			local.player stopwatch 0
	}
end

bomb_waittill_explode:
	self model items/explosive.tik
	self playsound plantbomb
	self loopsound bombtick
	
	local.start_time = level.time

	while (level.time < (local.start_time + level.bomb_tick_time) )
	{
		wait 0.1
		if (self.live != 1)
		{
			self stoploopsound
			end
		}
		if (level.time == (local.start_time + level.bomb_tick_time - 10) )
		{
			self stoploopsound
			self loopsound final_countdown
		}
 	}
 	self stoploopsound
	thread bomb_explode
end

bomb_explode:
	self.trigger_name remove

	thread global/obj_dm.scr::jitter_large 0
	
	if (self.exploder_set != NIL)
	{
		thread global/exploder.scr::explode self.exploder_set
	}
	
	if (self.explosion_fx != NIL)
		self thread global/obj_dm.scr::spawn_fx self.explosion_fx
	
	if (self.explosion_sound != NIL)
		self playsound self.explosion_sound

	if (self.target != NIL && self.target != NULL && self.target != "" && self.target.size == 1)
	{
		if (self.target.destroyed_model != NIL)
		{
			local.damaged = self.target thread spawn_damaged self.target.destroyed_model
		}

		if (self.exploder_set == NIL)
		{
			self.target remove
		}

		waitframe
	}
	radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	if (self.killarea != NIL)
	{
		self.killarea volumedamage 1000
	}
	self hide
	self notsolid
//	self remove
	
	self.live = 0
	
	self.exploded = 1
	level.targets_destroyed = level.targets_destroyed + 1

	if( self.objCvar != NIL && self.objCvar != NULL )
	{
		setcvar self.objCvar ""
	}


	// we delay the decrementing of	level.bombs_planted so that the script has
	// time to determin the winner before the timelimit gets checked and hit
	fadeout 1.35 0 0 0 1
	wait 0.5
	level.bombs_planted --

	teamwin allies // axis

end
