//-------------------------------------
main:
//-------------------------------------
	level.gametype = int( getcvar( g_gametype ) )
	// set scoreboard messages
	if( level.gametype == 4 )
	{
		// axistext
		setcvar "g_obj_axistext1" ( loc_convert_string "Protect the" )
		setcvar "g_obj_axistext2" ( loc_convert_string "Fort Supplies" )
		setcvar "g_obj_axistext3" ""
			
		// allies
		setcvar "g_obj_alliedtext1" ( loc_convert_string "Destroy the" ) 
		setcvar "g_obj_alliedtext2" ( loc_convert_string "Fort Supplies" )
		setcvar "g_obj_alliedtext3" ""

	}
	else
	{
		setcvar "g_obj_alliedtext1" ( loc_convert_string "Bizerte Festung" )
		setcvar "g_obj_alliedtext2" ""
		setcvar "g_obj_alliedtext3" ""
		setcvar "g_obj_axistext1" ""
		setcvar "g_obj_axistext2" ""
		setcvar "g_obj_axistext3" ""
	}
	
	setcvar "g_scoreboardpic" "mp_bizerte_dm"

	level.script = maps/obj/mp_bizertefort_obj.scr

	////////////////////	
	level waittill prespawn
	////////////////////
	
	exec global/DMprecache.scr
	exec global/door_locked.scr

	$crustywerfer nodamage
	$crustywerfer_turret0 nodamage

	if($collisionhull)
	{
		$collisionhull.angles = (0 0 0)
		$collisionhull.origin = $collisionhull.origin + (0 0 -300)
		$crustywerfer.collisionent =  $collisionhull
	}
//	$crustywerfer notsolid
//	$crustywerfer_turret0 notsolid

	if(level.gametype == 4)
		waitthread reverseSpawnPoints

	////////////////////
	level waittill spawn
	////////////////////
		
	if (level.gametype > 2) 
	{
		/////////////////////////
		level waittill roundstart
		/////////////////////////
	}
	level.dmroundlimit = 5   // round time limit in minutes
	if (level.gametype == 4) 
	{
		waitthread ObjectiveMode
	}
	
End

// Created Objective Mode
ObjectiveMode:
		
		local.bomborigin = ( -1346 -907 353)
		level.defusing_team = "axis" // allies
		level.planting_team = "allies"  // axis
		level.bombs_to_plant = 1
		level.bomb_damage = 600
		level.bomb_explosion_radius = 1024
		level.targets_to_destroy = 1
		level.bomb_defuse_time = 60 //tenths of a second
		level.bomb_set_time = 50  //tenths of a second
		level.bomb_explosion_radius = 1054  //quake units
		level.bomb_use_distance = 128 //quake units
		level.bomb_damage = 200
		level.bombusefov = 30

		level.subtitleX = 100
		level.subtitleY = 50
		level.allieswin = 0
		// set the parameters for this round/wave based match
		level.clockside = axis // set to axis, allies, kills, or draw
		
		spawn script_model "targetname" "bomb1" "model" "items/pulse_explosive.tik" "origin" local.bomborigin
		local.crate = spawn script_model "targetname" "fakecrate" "origin" ( -1346 -907 305)
		
		wait 1.0
		$bomb1.trigger_name = spawn trigger_use "origin" $bomb1.origin targetname "Bomb1Trigger"
		$bomb1.explosion_fx = "fx/fx_flak88_explosion.tik"
		$bomb1.explosion_sound = "explode_aagun"
		waitframe
		$bomb1.angle = -90
		$bomb1.trigger_name setsize ( -40 -40 -40) (40 40 40)
		if($fortcrates)
			thread bomb_exploded $bomb1 $fortcrates
		$bomb1 thread bomb_thinker
 

	  	thread allied_win_bomb
		thread axis_win_timer

		addobjective 1 1 "" $bomb1.origin
		setcurrentobjective 1
End

//*** --------------------------------------------
//*** Special effects macro
//*** --------------------------------------------

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp notsolid
	local.temp.origin = self.origin
	local.temp anim start
	local.temp playsound explode_truck1
	local.temp notsolid
	earthquake .5 2 1 0
	wait 5
	local.temp remove
end


//*** --------------------------------------------
//*** Explode all the crates near the bomb
//*** --------------------------------------------

explodeCrate:
	local.wait = 0.1 + randomfloat(0.6)
	wait local.wait
	self thread spawn_fx models/fx/fx_tank_explosion.tik
	wait 0.5
	self thread spawn_fx models/emitters/tehao_explosionDust.tik
end


//*** --------------------------------------------
//*** Wait for a bomb to go off
//*** --------------------------------------------

bomb_exploded local.bomb local.crates:
	while (local.bomb)
		wait .1

 	level.axiswin = 1

	local.crates waitthread explodeCrate

	teamwin allies
end

//*** --------------------------------------------
//*** "Axis Victory"
//*** --------------------------------------------
AxisVictory:
   	while (level.axiswin != 1) 
		wait 0.1

	teamwin axis

end

allied_win_bomb:

	level waittill allieswin

end

//*** --------------------------------------------
//*** "Allied Victory"
//*** --------------------------------------------

axis_win_timer:

	level waittill axiswin

end



//*** --------------------------------------------
//*** Bomb Code
//*** --------------------------------------------
bomb_thinker:
	level.bomb_defuse_time = 20 //tenths of a second
	level.bomb_set_time = 50  //tenths of a second, 50
	level.bomb_tick_time = 15  //seconds, 15
	level.bomb_explosion_radius = 500  //quake units
	level.bomb_use_distance = 128 //quake units
	level.bomb_damage = 200000
	level.bombusefov = 30

	level.subtitleX = 100
	level.subtitleY = 50
	
	self.live = 0

	if (self.target != NIL && self.target != NULL && $(self.target) != NULL)
	{
		self.target.collisionent = self.target.target
		self.target notsolid
	}

	thread bomb_waittill_set
end

bomb_waittill_set:
	self model items/pulse_explosive.tik
	while ( $(self.trigger_name) )
	{
		self.trigger_name waittill trigger
		local.player = parm.other

	        if (local.player.dmteam != level.planting_team) 
		{
			local.player iprint ( loc_convert_string "You are the wrong team to plant a bomb here!" )
			goto bomb_waittill_set
		}

		local.counter = 0
		while ( (Isalive local.player) && 
				(local.player cansee self level.bombusefov level.bomb_use_distance) && 
				(local.player.useheld == 1) && self.live == 0 )
		{
			if (local.counter == 0)
				local.player stopwatch (level.bomb_set_time * .1)
				
			local.counter++
			wait 0.1

			if (local.counter >= level.bomb_set_time)
			{
				iprintlnbold ( loc_convert_string "The Allies have Planted a Bomb!" )
				if (level.planting_team == "allies")
					self playsound dfr_objective_o
				else
					self playsound den_objective_o

				thread bomb_waittill_defuse
				thread bomb_waittill_explode

				self.live = 1
				level.bombs_planted ++
				end
			}
		}
		if (local.counter > 0)
			local.player stopwatch 0
	}
end


bomb_waittill_defuse:
	while ( $(self.trigger_name) )
	{
		self.trigger_name waittill trigger

		local.player = parm.other
	
		if (local.player.dmteam != level.defusing_team)
		{      
			local.player iprint ( loc_convert_string "You're on the wrong team to defuse this bomb!" )
			goto bomb_waittill_defuse
		}
	
		local.counter = 0
		while ( (Isalive local.player) && 
				(local.player cansee self level.bombusefov level.bomb_use_distance) && 
				(local.player.useheld == 1) && self.live == 1 )
		{
			if (local.counter == 0)
				local.player stopwatch (level.bomb_defuse_time * .1)
			
			local.counter++
			wait 0.1

			if (local.counter >= level.bomb_defuse_time)
			{
				iprintlnbold ( loc_convert_string "The Axis have Defused a Bomb!" )
				if (level.defusing_team == "axis")
					self playsound dfr_diffused_d
				else
					self playsound den_diffused_d
				thread bomb_waittill_set //start first thread again
				self.live = 0
				level.bombs_planted --
				end
			}
		}
		if (local.counter > 0)
			local.player stopwatch 0
	}
end

bomb_waittill_explode:
	self model items/explosive.tik
	self playsound plantbomb
	self loopsound bombtick
	
	local.start_time = level.time

	while (level.time < (local.start_time + level.bomb_tick_time) )
	{
		wait 0.1
		if (self.live != 1)
		{
			self stoploopsound
			end
		}
		if (level.time == (local.start_time + level.bomb_tick_time - 10) )
		{
			self stoploopsound
			self loopsound final_countdown
		}
 	}
 	self stoploopsound
	thread bomb_explode
end

bomb_explode:
	self.trigger_name remove

	thread global/obj_dm.scr::jitter_large 0
	
	if (self.exploder_set != NIL)
	{
		thread global/exploder.scr::explode self.exploder_set
	}
	
	if (self.explosion_fx != NIL)
		self thread global/obj_dm.scr::spawn_fx self.explosion_fx
	
	if (self.explosion_sound != NIL)
		self playsound self.explosion_sound

	if (self.target != NIL && self.target != NULL && self.target != "" && self.target.size == 1)
	{
		if (self.target.destroyed_model != NIL)
		{
			local.damaged = self.target thread spawn_damaged self.target.destroyed_model
		}

		if (self.exploder_set == NIL)
		{
			self.target remove
		}

		waitframe
	}
	radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	if (self.killarea != NIL)
	{
		self.killarea volumedamage 1000
	}
	self hide
	self notsolid
//	self remove
	
	self.live = 0
	
	self.exploded = 1
	level.targets_destroyed = level.targets_destroyed + 1

	if( self.objCvar != NIL && self.objCvar != NULL )
	{
		setcvar self.objCvar ""
	}


	// we delay the decrementing of	level.bombs_planted so that the script has
	// time to determin the winner before the timelimit gets checked and hit

	fadeout 0.85 0 0 0 1

	wait 0.5
	level.bombs_planted --


	teamwin allies // axis

end

reverseSpawnPoints:
	if(!($axisspawn) || !($alliedspawn))
		End
	local.axis = $axisspawn.size 
	local.allies = $alliedspawn.size
	if(local.axis > local.allies)
		{
			for(local.a = 1; local.a <= local.allies; local.a++)
			{
				local.temporigin = $axisspawn[local.a].origin
				local.tempangles = $axisspawn[local.a].angles
				$axisspawn[local.a].origin = $alliedspawn[local.a].origin
				$axisspawn[local.a].angles = $alliedspawn[local.a].angles

				$alliedspawn[local.a].origin = local.temporigin
				$alliedspawn[local.a].angles = local.tempangles
			}
			for(local.b = local.allies + 1; local.b <= local.axis; local.b++)
				$axisspawn[local.a] disablespawn
		}
	else
		{
			for(local.a = 1; local.a <= local.axis; local.a++)
			{
				local.temporigin = $axisspawn[local.a].origin
				local.tempangles = $axisspawn[local.a].angles
				$axisspawn[local.a].origin = $alliedspawn[local.a].origin
				$axisspawn[local.a].angles = $alliedspawn[local.a].angles

				$alliedspawn[local.a].origin = local.temporigin
				$alliedspawn[local.a].angles = local.tempangles
			}
			for(local.b = local.axis + 1; local.b <= local.allies; local.b++)
				$alliedspawn[local.a] disablespawn
		}	
	
End

