///////////////////////////////////////////////////////////////////////////////
//
//  MoH: Allied Assault Script File  
//  Level: M3L1b - D-Day, bunker and back-field section
//  Script Written By: Benson 'elmagoo' Russell
//
///////////////////////////////////////////////////////////////////////////////

//*************************************************************
//*************************************************************
//*************************************************************
//
// INIT SECTION
//
//*************************************************************
//*************************************************************
//*************************************************************

start:
//*** set the soundtrack
soundtrack music/m3l1b.mus

//*** modifications for AI paths with entities in the way
$e2_table notsolid
$door_bunker_exit notsolid

//*** prep the players weapons
exec global/loadout.scr maps/m3l1b.scr

//*************************************************************
//  wait for the level to spawn
//*************************************************************
level waittill prespawn

//*** disconnect paths
$door_bunker_exit disconnect_paths

//*** prep the level and ai
thread level_prep
thread ai_prep
//thread player_prep

//*** init variables
thread variable_prep

//*** initialize the minefields
thread global/minefield.scr::minefield_setup

//*** setup the crates N barrels
thread global/crate.scr::item_crate
thread global/crate.scr::explosive_crate
thread global/barrel.scr::explosive_barrel

//*************************************************************
//  player enters the game
//*************************************************************
level waittill spawn

//*** TEMP reset the Objectives portion of the HUD
//waitthread global/objectives.scr::reset_objectives
//waitthread global/objectives.scr::blank_objectives

//*** set the starting objectives for the level
/*
waitthread global/objectives.scr::add_objectives 1 2 "Destroy the 2 20mm Anti-Aircraft gun emplacements" $20mm_weapon1.origin
waitthread global/objectives.scr::add_objectives 2 2 "Destroy the FLAK 88 Artillery emplacement" $88mm_weapon.origin
waitthread global/objectives.scr::add_objectives 3 2 "Destroy the 15cm Artillery emplacement" $15cm_weapon.origin
waitthread global/objectives.scr::add_objectives 4 2 "Meet up at the rendevous point" $rendevous_point.origin
*/

waitthread global/objectives.scr::add_objectives 1 2 "Clear out the bunker." $mg42_bunker_2_gunner
waitthread global/objectives.scr::current_objectives 1

//*** give starting inventory items
//waitthread global/items.scr::add_item "explosives"

//*** start the bunker dust falling
thread bunker_dust_trigger

//*** play the proper ambient track
forcemusic normal normal

//*** set the current objective
waitthread global/objectives.scr::current_objectives 1

//*** setting ambient sounds on objects
thread ambient

end


//*************************************************************
//*************************************************************
//
// INIT THREADS
//
//*************************************************************
//*************************************************************

//*********************************************
// init variables
//*********************************************
variable_prep:

println "XXX Preping the variables"

//*** player location variable
$player.progress = "bunker_lower"

//*** objective variables
level.88mm_weapon_objective = 0
level.20mm_weapon1_objective = 0
level.20mm_weapon2_objective = 0
level.15cm_weapon_objective = 0
level.objective_completed = 0

//*** far bunker counter
level.far_bunker_done = 0
level.clear_farbunker_gunner = 0
level.clear_bunker = 0

end


//*********************************************
// prep the ai
//*********************************************
ai_prep:

println "XXX Preping the AI"

//*** lower level troops
$weh_sol_bunker_lower_1 exec global/disable_ai.scr
$weh_sol_bunker_lower_1.interval = 0
$weh_sol_bunker_lower_1 thread weh_sol_bunker_lower_1_death

$weh_sol_bunker_lower_2 exec global/disable_ai.scr
$weh_sol_bunker_lower_2.interval = 0
$weh_sol_bunker_lower_2 thread weh_sol_bunker_lower_2_death

$weh_sol_bunker_lower_3.interval = 0
$weh_sol_bunker_lower_3 thread weh_sol_bunker_lower_3_death

$weh_sol_bunker_lower_4 exec global/disable_ai.scr
$weh_sol_bunker_lower_4.interval = 0
$weh_sol_bunker_lower_5 exec global/disable_ai.scr
$weh_sol_bunker_lower_5.interval = 0

//*** middle level troops
$weh_sol_bunker_middle_1 exec global/disable_ai.scr
$weh_sol_bunker_middle_1 exec global/setdeathanim.scr "death_fall_back"
$weh_sol_bunker_middle_1.health = 10
$weh_sol_bunker_middle_1.interval = 0
$weh_sol_bunker_middle_2 exec global/disable_ai.scr
$weh_sol_bunker_middle_2.interval = 0
$weh_sol_bunker_middle_3 exec global/enable_ai.scr
$weh_sol_bunker_middle_3.interval = 0
$weh_sol_bunker_middle_4 exec global/enable_ai.scr
$weh_sol_bunker_middle_4.interval = 0
$weh_sol_bunker_middle_5 exec global/enable_ai.scr
$weh_sol_bunker_middle_5.interval = 0

$weh_off_bunker_middle_1 exec global/disable_ai.scr

//*** upper level troops
$weh_sol_bunker_upper_1 exec global/disable_ai.scr
$weh_sol_bunker_upper_1.interval = 0
$weh_sol_bunker_upper_1 thread upper_bunker_death
$weh_sol_bunker_upper_2 exec global/disable_ai.scr
$weh_sol_bunker_upper_2.interval = 0
$weh_sol_bunker_upper_2 thread upper_bunker_death

$weh_nco_bunker_upper_1 exec global/disable_ai.scr
$weh_nco_bunker_upper_1.interval = 0
$weh_nco_bunker_upper_1 thread upper_bunker_death

$weh_off_bunker_upper_1 exec global/disable_ai.scr
$weh_off_bunker_upper_1.interval = 0
$weh_off_bunker_upper_1 thread weh_off_bunker_upper_1_pain
$weh_off_bunker_upper_1 thread upper_bunker_death

//*** guys running into the bunker
$weh_nco_bunker_exit_1 exec global/disable_ai.scr
$weh_nco_bunker_exit_1.interval = 0
$weh_sol_bunker_exit_1 exec global/disable_ai.scr
$weh_sol_bunker_exit_1.interval = 0
$weh_sol_bunker_exit_2 exec global/disable_ai.scr
$weh_sol_bunker_exit_2.interval = 0

/*
//*** TEMP TEMP TEMP POOPHEAD ENDING
$weh_nco_bunker_exit_1 remove
$weh_sol_bunker_exit_1 remove
$weh_sol_bunker_exit_2 remove
*/

//*** top level retreating guys
$weh_nco_retreat_1 exec global/disable_ai.scr
$weh_nco_retreat_1.interval = 0
$weh_sol_retreat_2 exec global/disable_ai.scr
$weh_sol_retreat_2.interval = 0
$weh_sol_retreat_3 exec global/disable_ai.scr
$weh_sol_retreat_3.interval = 0

//*** mg42 gunners
$mg42_middle1_gunner  exec global/disable_ai.scr
$mg42_middle2_gunner  exec global/disable_ai.scr

$mg42_bunker_1_gunner thread mg42_bunker_1_gunner_pain
$mg42_bunker_2_gunner thread mg42_bunker_2_gunner_pain
$mg42_bunker_1_gunner thread mg42_bunker_1_gunner_death
$mg42_bunker_2_gunner thread mg42_bunker_2_gunner_death
$mg42_bunker_1_gunner thread upper_bunker_death
$mg42_bunker_2_gunner thread upper_bunker_death

end


//*********************************************
// prep the player
//*********************************************
player_prep:

println "XXX Preping the player"

//*** Allied weapons
//$player item weapons/colt45.tik
//$player item weapons/silencedpistol.tik
//$player item weapons/m1_garand.tik
//$player item weapons/Springfield.tik
//$player item weapons/ThompsonSMG.tik
//$player item weapons/BAR.tik
//$player item weapons/M2frag_grenade_sp.tik
//$player item weapons/bazooka.tik
//$player item weapons/shotgun.tik

//*** German weapons
//$player item weapons/P38.tik    
//$player item weapons/KAR98.tik
//$player item weapons/KAR98sniper.tik
//$player item weapons/mp40.tik
//$player item weapons/mp44.tik
//$player item weapons/steilhandgranate.tik
//$player item weapons/panzerschreck.tik

//*** give ammo
//$player ammo pistol 80
//$player ammo rifle 200
//$player ammo smg 200
//$player ammo mg 400
//$player ammo grenade 4
//$player ammo shotgun 80
//$player ammo heavy 4

//*** which gun the player will ready at the start
//$player useweaponclass pistol
//$player useweaponclass rifle
//$player useweaponclass smg
//$player useweaponclass mg
//$player useweaponclass grenade
//$player useweaponclass shotgun
//$player useweaponclass heavy

end


//*********************************************
// prep the level, set initial time values,
// move objects to starting positions
//*********************************************
level_prep:

println "XXX Preping the level"

//*** setup player progress triggers
thread setup_progress

//*** setup beach rush allied spawners and paths
thread setup_beach_spawners

//*** setup beach target eligibilty triggers
thread setup_beach_target_triggers

//*** setup the two mg42s in the main bunker
$mg42_bunker_1 burstfiresettings 1 3 .2 .75
$mg42_bunker_1 firedelay .08
$mg42_bunker_1 tracerfrequency 4
$mg42_bunker_1 maxyawoffset 30
$mg42_bunker_1 pitchcaps (0 30 0)
$mg42_bunker_1 setplayerusable 0
$mg42_bunker_1 bulletspread 5 7
$mg42_bunker_1 setaimtarget $mg42_bunker_target

$mg42_bunker_2 burstfiresettings 1 3 .2 .75
$mg42_bunker_2 firedelay .08
$mg42_bunker_2 tracerfrequency 4
$mg42_bunker_2 maxyawoffset 30
$mg42_bunker_2 pitchcaps (0 30 0)
$mg42_bunker_2 setplayerusable 0
$mg42_bunker_2 bulletspread 5 7
$mg42_bunker_2 setaimtarget $mg42_bunker_target

$mg42_bunker_upper maxyawoffset 7
$mg42_bunker_upper bulletspread 5 7
$mg42_bunker_upper pitchcaps ( -1 10 0)

//*** setup the two mg42s in the middle
$mg42_middle1 burstfiresettings 1 3 .2 .75
$mg42_middle1 firedelay .08
$mg42_middle1 tracerfrequency 4
$mg42_middle1 maxyawoffset 30
$mg42_middle1 pitchcaps (0 30 0)
$mg42_middle1 setplayerusable 0
$mg42_middle1 bulletspread 5 7
$mg42_middle1 setaimtarget $mg42_middle1_target

$mg42_middle2 burstfiresettings 1 3 .2 .75
$mg42_middle2 firedelay .08
$mg42_middle2 tracerfrequency 4
$mg42_middle2 maxyawoffset 30
$mg42_middle2 pitchcaps (0 30 0)
$mg42_middle2 setplayerusable 0
$mg42_middle2 bulletspread 5 7
$mg42_middle2 setaimtarget $mg42_middle2_target

//*** trigger brushes
$door_floor_hatch1_lock nottriggerable
$end_level_trigger nottriggerable

//*** solidifying objects after paths
$e2_table solid
$door_bunker_exit solid

end


//*********************************
//*********************************
//*** setup beach spawners and paths
setup_beach_spawners:

for (local.i = 1; local.i <= $allied_beach_path.size; local.i ++)
{
	local.lookup[$allied_beach_path[local.i].set] = local.i
}

for (local.i = 1; local.i <= $allied_beach_spawn.size ; local.i ++)
{
	$allied_beach_spawn[local.i].path_index = local.lookup[$allied_beach_spawn[local.i].set]
}

local.lookup = NIL

end


//*******************************
//*******************************
//*** setup progress triggers
setup_progress:

for (local.i = 1 ; local.i <= $progress_player.size ; local.i ++)
{
	$progress_player[local.i] thread progress_player local.i
}

end


//*******************************
//*******************************
//*** setup target eligibility triggers
setup_beach_target_triggers:

for (local.i = 1 ; local.i <= $allied_beach_target.size ; local.i ++)
{
	$allied_beach_target[local.i] thread allied_beach_target local.i
}

end


//*********************************************
// setting ambient sounds on objects in the level
//*********************************************
ambient:

$bunker_radio loopsound m3l1b_radio2

end


//*************************************************************
//*************************************************************
//
// GAME OBJECT BACKGROUND THREADS
//
//*************************************************************
//*************************************************************

//*********************************************
// progress triggers for tracking the player
//*********************************************
progress_player local.index:

progress_player_loop:
local.self waittill trigger

$player.progress = local.self.area

//println "PLAYER PROGRESS: player is now in area: " $player.progress

if ($player.progress == "bunker_lower")
{
	//*** change the ambient track
	forcemusic normal normal
	
	//*** change the world fog
	$world farplane 0
	$world farplane_color (0 0 0)
}
else if ($player.progress == "bunker_upper")
{
	//*** change the ambient track
	forcemusic normal normal
	
	//*** change the world fog
	$world farplane 6500
	$world farplane_color (0.675 0.663 0.651)
}
else if ($player.progress == "bunker_deck")
{
	//*** change the world fog
	$world farplane 5000
	
	/*
	//*** show the AI running up the beach
	for (local.i = 1; local.i <= 14 ; local.i ++)
        {
		local.guy = $(allied_beach + local.i)
        	if (local.guy.targetname != NULL || local.guy.targetname != NIL)
                {
                        //*** show the AI guy
                        local.guy show
                }		
        }
	*/
}
else if ($player.progress == "backfield")
{
	//*** change the ambient track
	forcemusic aux4 aux4
	
	//*** change the world fog
	$world farplane 4500
}

wait .5

goto progress_player_loop

end


//*********************************************
// beach scene target eligibilty triggers
//*********************************************
allied_beach_target local.index:

//*** used for guys in the beach scene to see if they're too far to be shot by the MG42s
allied_beach_target_loop:
local.self waittill trigger

local.ai_dude = parm.other

local.ai_dude.select = local.self.select

wait 1

goto allied_beach_target_loop

end


//******************************
//  running the beach scene
//******************************
beach_scene_targeting:

beach_scene_targeting_loop:
//*** pick a guy
local.choice = (randomint 20 + 1)
local.guy = $("allied_beach" + local.choice)

//println "BEACH TARGETING: " local.self " has choosen: " local.guy

//*** if the guy choosen is non-existent
if !(isalive local.guy)
{
	//println "BEACH TARGETING: " local.self " picked non-existent target, reselecting" 
	goto beach_scene_targeting_next
}

//*** if the guy choosen is not eligble
if (local.guy.select != 1)
{
	//println "BEACH TARGETING: " local.self " picked a non eligble target, select: " local.guy.select " : reselecting"
	goto beach_scene_targeting_next
}

//*** keep firing at him till he's dead, the gunner's dead, or the guy is no longer valid
while ((isalive local.guy) && local.guy.select == 1 && local.self.hasgunner == 1)
{
	//println "BEACH TARGETING: " local.self " attacking target: " local.guy
	local.self.setaimtarget = local.guy
	wait 1.5
}

//println "BEACH TARGETING: " local.self " target is no longer valid"

beach_scene_targeting_next:

//println "BEACH TARGETING: " local.self " has this many spawns left: " local.self.spawn_left

//println "FAR BUNKER: " local.self " has a spawn_left of: " local.self.spawn_left

if (local.self.has_gunner == 0)
{
	//println "BEACH TARGETING: " local.self " has no more gunners"
	goto beach_scene_targeting_done
}

//println "BEACH TARGETING: " local.self " defaulting to default target"

local.self.setaimtarget = $mg42_farbunker_target
wait 2

goto beach_scene_targeting_loop

beach_scene_targeting_done:

level.far_bunker_done ++

//println "FAR BUNKER: spawn level.far_bunker_done: " level.far_bunker_done
/*
//*** TEMP TEMP TEMP  PREMATURE POOPHEAD ENDING
//*** if all the farbunker gunners are dead, allow the level to end
if (level.far_bunker_done >= 2)
{
	//*** complete the objective 
	waitthread global/objectives.scr::add_objectives 2 3
	
	waitthread global/objectives.scr::add_objectives 3 2 "Exit the bunker." $end_level_trigger.origin
	waitthread global/objectives.scr::current_objectives 3
	
	$end_level_trigger triggerable
}
*/
end


//******************************
//  beach scene mortar calls
//******************************
beach_scene_mortar:

//println "BEACH SCENE MORTAR: starting beach mortar1"

local.poop = 1

while (local.poop == 1)
{

beach_scene_mortar_pickagain:
	//*** pick the mortar
	local.choice = (randomint $beach_scene_mortar.size + 1)
	
	//println "BEACH SCENE MORTAR: picked mortar: " local.choice
	
	//*** check to see if it picked the same one from before, if so, pick again
	if (local.choice == local.previous_choice)
        {
		//println "BEACH SCENE MORTAR: was the previous choice, picking again!"
        	goto beach_scene_mortar_pickagain
        }
	
	local.previous_choice = local.choice
	
	//println "BEACH SCENE MORTAR: playing the sound"
	$mg42_farbunker_target playsound arty_leadin wait
	$mg42_farbunker_target waittill sounddone
	
	//println "BEACH SCENE MORTAR: firing the mortar: " local.choice
	
	//*** fire the mortar
	$beach_scene_mortar[local.choice] anim start
	
	radiusdamage $beach_scene_mortar[local.choice].origin 1000 384
	
	wait (randomint 5 + 4)
}

end


//******************************
//  running the beach scene
//******************************
beach_scene:

beach_scene_loop:
//println "BEACH SCENE: starting"
local.wait_index = 0
local.wait_count = (randomint 4 + 4)

//*** set the number of guys based on detail settings
if (getcvar(g_ddayshingleguys) == "0")  //*** low setting
{
	//println "BEACH SCENE: low settings for spawning guys"
	local.ai_count = 6
}
else if (getcvar(g_ddayshingleguys) == "1")  //*** medium setting
{
	//println "BEACH SCENE: medium settings for spawning guys"
	local.ai_count = 12
}
else  //*** high setting
{
	//println "BEACH SCENE: high settings for spawning guys"
	local.ai_count = 20
}

for (local.i = 1; local.i <= local.ai_count ; local.i ++)
{
	//println "BEACH SCENE: current guy in loop to spawn: " ("allied_beach" + local.i) " : status:" $("allied_beach" + local.i)  
	if ($("allied_beach" + local.i) != NULL)
        {
        	goto beach_scene_next
        }
	
	//println "BEACH SCENE: top of loop, index: " local.i
	//*** select the type of allied troop to spawn and his weapon
	local.choice = randomint 10
	
	//println "BEACH SCENE: random troop number: " local.choice
	
	switch (local.choice)
	{
		case 0:
		
		case 1:
		
		case 2:
			local.model = "models/human/dday_ranger_private"
			local.gun = "m1 garand"
			//println "BEACH SCENE: selected a private with garand"
			break
		
		case 3:
		
		case 4:
		
		case 5:
			local.model = "models/human/dday_ranger_private"
			local.gun = "bar"
			//println "BEACH SCENE: selected a private with BAR"
			break
			
		case 6:
			local.model = "models/human/dday_ranger_lieutenant"
			local.gun = "thompson"
			//println "BEACH SCENE: selected a lieutenant with thompson"
			break
		
		case 7:
		
		case 8:
			local.model = "models/human/dday_ranger_sergeant"
			local.gun = "m1 garand"
			//println "BEACH SCENE: selected a sergeant with a garand"
			break

		case 9:
			local.model = "models/human/dday_ranger_captain"
			local.gun = "thompson"
			//println "BEACH SCENE: selected a captain with a thompson"
			break
	}
	
	local.guy = ("allied_beach" + local.i)
	
	//*** spawn him in
	spawn local.model targetname local.guy gun local.gun
	local.guy = $("allied_beach" + local.i)
	
	//*** set the guy up
	local.guy waitthread ai_allied_beach_setup
	
	//*** position him
	local.choice = (randomint 14 + 1)
	local.guy.origin = $allied_beach_spawn[local.choice].origin
	
	//println "BEACH SCENE: spawned the guy to location index: " local.choice
	
	//*** make him run his path
	local.guy thread ai_allied_beach_takepath local.choice
	local.guy forceactivate

	//*** cycle to the next guy after waiting
	wait (randomfloat .75 + .75)
	
	local.wait_index ++
	
	//*** every so many troop put a larger wait in to form gaps in the timing
	if (local.wait_index > local.wait_count)
        {
		//println "BEACH SCENE: cycle timing pause"
        	wait (randomint 3 + 3)
		local.wait_index = 0
		local.wait_count = (randomint 4 + 4)
        }
	
beach_scene_next:
}

wait 7
goto beach_scene_loop

beach_scene_done:
//println "BEACH SCENE: exiting"

end


//******************************
//  Dust triggers in the bunker
//******************************
bunker_dust_trigger:

bunker_dust_trigger_loop:
//println "DUST: checking to see player is in bunker"
while ($player.progress == "bunker_lower" || $player.progress == "bunker_upper")
{
	//println "DUST: player is in bunker, hit with a mortar"
	$player playsound arty_exp_interior
	thread jitter_small
	
	wait .75
	for (local.i = 1 ; local.i <= $bunker_dust1.size ; local.i ++)
	{
		$bunker_dust1[local.i] anim start
		//wait (randomfloat .15 + .1)
	}

	wait (randomint 5 + 15)
}
//println "DUST: player is not in bunker, cycle"
wait 5

goto bunker_dust_trigger_loop

end

/*
//***************************************************
//  flakk 88 firing
//***************************************************
88mm_weapon_firing:

//*** while the crew is alive and the gun is not destroyed, fire out to sea
while (level.88mm_weapon_stopfiring != 1)
{
	$88mm_weapon_gunnery_commander anim 88officer_fire
	$88mm_weapon_gunnery_commander waittill animdone
	
	$88mm_weapon_gunnery_commander anim 88officer_idle
	$88mm_weapon_gunnery_operator anim 88operator_turnleft
	$88mm_weapon_gunnery_operator waittill animdone

	$88mm_weapon_gunnery_operator anim 88operator_idle
	$88mm_weapon_gunnery_commander anim 88officer_coverears
	
	wait .5
	$88mm_weapon_gunnery_operator anim 88operator_takecover

	wait .3
	$88mm_weapon anim fire
	
	//*** if the player is closer than 256 units jitter his view
	if (vector_length ($88mm_weapon.origin - $player.origin) < 512)
	{
		thread jitter_artillery 0
	}
	
	wait .15
	$88mm_weapon_base time .2
	$88mm_weapon_base movenorth 24
	$88mm_weapon_base moveeast 24
	$88mm_weapon_base waitmove
	
	$88mm_weapon_base time .3
	$88mm_weapon_base movenorth 5
	$88mm_weapon_base moveeast 5
	$88mm_weapon_base waitmove

	wait 1

	$88mm_weapon_gunnery_commander anim 88officer_idle

	$88mm_weapon_base time 2.5
	$88mm_weapon_base movesouth 21
	$88mm_weapon_base movewest 21
	$88mm_weapon_base waitmove
	
	$88mm_weapon_gunnery_operator anim 88operator_twitch

	$88mm_weapon_base time 2
	$88mm_weapon_base movesouth 8
	$88mm_weapon_base movewest 8
	$88mm_weapon_base waitmove

	$88mm_weapon_gunnery_operator anim 88operator_idle
	wait 2
}

end
*/

//*************************************************************
//*************************************************************
//
// GAME THREADS
//
//*************************************************************
//*************************************************************

//******************************
//  TEMP TEMP TEMP POOPHEAD ENDING
//******************************
end_level_thread:

//*** fadeout
fadeout 5 0 0 0 1

//*** give the medal
setcvar "g_medal5" "1"

waitthread global/objectives.scr::add_objectives 3 3
waitthread global/objectives.scr::current_objectives 0

//*** end the level
exec global/missioncomplete.scr m3l2

end


//***********************************
//  check to clear upper bunker objective
//***********************************
clear_bunker_objective:

println "CLEAR BUNKER COUNTER: " level.clear_bunker

if (level.clear_bunker >= 6)
{
	waitthread global/objectives.scr::add_objectives 1 3
	
	//*** check to see if the farbunker gunner objective has been cleared as well, if so, add the exit level objective
	if (level.clear_farbunker_gunner >= 2)
        {
        	//*** open the bunker door and send the guys in
        	thread seq_bunker_upper_exit
        	
        	//*** activate the end level trigger
        	$end_level_trigger triggerable    	
        	
        	//*** complete the objectives
        	waitthread global/objectives.scr::add_objectives 2 3
        	
        	waitthread global/objectives.scr::add_objectives 3 2 "Exit the bunker." $end_level_trigger.origin
        	waitthread global/objectives.scr::current_objectives 3	
        }
	else
	{
		waitthread global/objectives.scr::current_objectives 2
	}
}

end


//***********************************
//  check to clear farbunker gunners
//***********************************
clear_farbunker_gunner_objective:

println "CLEAR FARGUNNER COUNTER: " level.clear_farbunker_gunner

if (level.clear_farbunker_gunner >= 2)
{
	waitthread global/objectives.scr::add_objectives 2 3

	//*** check to see if the bunker gunner objective has been cleared as well, if so, add the exit level objective
	if (level.clear_bunker >= 6)
        {
        	//*** open the bunker door and send the guys in
        	thread seq_bunker_upper_exit
        	
        	//*** activate the end level trigger
        	$end_level_trigger triggerable    	
        	
        	//*** complete the objectives
        	waitthread global/objectives.scr::add_objectives 2 3
        	
        	waitthread global/objectives.scr::add_objectives 3 2 "Exit the bunker." $end_level_trigger.origin
        	waitthread global/objectives.scr::current_objectives 3
        }
	else
	{
		waitthread global/objectives.scr::current_objectives 1
	}
}

end


//*********************************************
// open the lower bunker door
//*********************************************
open_door_bunker_entrance_lower:

local.distance = vector_length($weh_sol_bunker_lower_1.origin - $door_bunker_entrance_lower.origin)
//println "DOOR: local.distance: " local.distance

while ((isalive $weh_sol_bunker_lower_1) && local.distance < 92)
{
	if (local.playsound != 1)
	{
		local.playsound = 1
		$door_bunker_entrance_lower playsound door_metal_locked
	}
	
	//println "DOOR: dude is alive"
	//println "DOOR: local.distance: " local.distance
	local.distance = vector_length($weh_sol_bunker_lower_1.origin - $door_bunker_entrance_lower.origin)
	wait .5
}

$door_bunker_entrance_lower time 1
$door_bunker_entrance_lower playsound metal_bunker_door_open
$door_bunker_entrance_lower rotateYup 90
$door_bunker_entrance_lower waitmove

end

//*********************************************
// close the door floor hatch1
//*********************************************
close_door_floor_hatch1:

$bunker_middle_ladder remove

$door_floor_hatch1 time .75
$door_floor_hatch1 playsound metal_bunker_hatch_open
$door_floor_hatch1 rotateXdown 90
$door_floor_hatch1 waitmove

thread seq_bunker_middle_start

$door_floor_hatch1_lock triggerable

end


//****************************************
//*** locked bunker floor hatch1
//****************************************
door_metal_lock:

local.self playsound door_metal_locked

//thread global/message_print.scr::message "This door is locked!!" 0 1

end


/*
//*********************************************
// flakk 88 objective, destroy with explosives
//*********************************************
88mm_weapon_set_explosive:

$88mm_weapon_explosive model animate/explosive.tik

wait 4
$88mm_weapon_exploder anim start

radiusdamage $88mm_weapon_exploder.origin 1000 448

//*** shake the players view
thread jitter_large

level.88mm_weapon_objective = 1

level.88mm_weapon_stopfiring = 1
//$88mm_weapon remove

//*** swap the model out for the destroyed version
$88mm_weapon model statweapons/flak88_d.tik
$88mm_weapon_explosive remove

//*** update the objectives
waitthread global/objectives.scr::add_objectives 2 3

thread check_current_objective

end


//***********************************************
// flakk 30-1 objective, destroy with explosives
//***********************************************
20mm_weapon1_set_explosive:

$20mm_weapon1_explosive model animate/explosive.tik

wait 4
$20mm_weapon1_exploder anim start

radiusdamage $20mm_weapon1_exploder.origin 1000 448

//*** shake the players view
thread jitter_large 0

level.20mm_weapon1_objective = 1
$20mm_weapon1 remove
$20mm_weapon1_explosive remove

//*** update the objectives
if (level.20mm_weapon2_objective == 1)
{
	waitthread global/objectives.scr::add_objectives 1 3 "Destroy the 20mm Anti-Aircraft gun emplacements"
}
else
{
	waitthread global/objectives.scr::add_objectives 1 2 "Destroy the 1 20mm Anti-Aircraft gun emplacement" $20mm_weapon2.origin
}
	
thread check_current_objective

end


//***********************************************
// flakk 30-2 objective, destroy with explosives
//***********************************************
20mm_weapon2_set_explosive:

$20mm_weapon2_explosive model animate/explosive.tik

wait 4
$20mm_weapon2_exploder anim start

radiusdamage $20mm_weapon2_exploder.origin 1000 448

//*** shake the players view
thread jitter_large 0

level.20mm_weapon2_objective = 1
$20mm_weapon2 remove
$20mm_weapon2_explosive remove

//*** update the objectives
if (level.20mm_weapon1_objective == 1)
{
	waitthread global/objectives.scr::add_objectives 1 3 "Destroy the 20mm Anti-Aircraft gun emplacements"
}
else
{
	waitthread global/objectives.scr::add_objectives 1 2 "Destroy the 1 20mm Anti-Aircraft gun emplacement" $20mm_weapon1.origin
}
	
thread check_current_objective

end


//***********************************************
// 15cm canon objective, destroy with explosives
//***********************************************
15cm_weapon_set_explosive:

$15cm_weapon_explosive model animate/explosive.tik

wait 4
$15cm_weapon_exploder anim start

radiusdamage $15cm_weapon_exploder.origin 1000 448

//*** shake the players view
thread jitter_large 0

level.15cm_weapon_objective = 1
$15cm_weapon remove
$15cm_weapon_explosive remove

//*** update the objectives
waitthread global/objectives.scr::add_objectives 3 3
	
thread check_current_objective

end


//*********************************************
// check what objective to set as current
//*********************************************
check_current_objective:

if (level.20mm_weapon1_objective != 1)
{
	waitthread global/objectives.scr::current_objectives 1
	
	//*** check to see if this is the last destroy objective completed
	if (level.20mm_weapon2_objective == 1 && level.88mm_weapon_objective == 1 && level.15cm_weapon_objective == 1)
	{
		level.objective_completed = 1
	}
}
else if (level.20mm_weapon2_objective != 1)
{
	waitthread global/objectives.scr::current_objectives 1

	//*** check to see if this is the last destroy objective completed
	if (level.20mm_weapon1_objective == 1 && level.88mm_weapon_objective == 1 && level.15cm_weapon_objective == 1)
	{
		level.objective_completed = 1
	}
}
else if (level.88mm_weapon_objective != 1)
{
	waitthread global/objectives.scr::current_objectives 2

	//*** check to see if this is the last destroy objective completed
	if (level.20mm_weapon1_objective == 1 && level.20mm_weapon2_objective == 1 && level.15cm_weapon_objective == 1)
	{
		level.objective_completed = 2
	}
}
else if (level.15cm_weapon_objective != 1)
{
	waitthread global/objectives.scr::current_objectives 3

	//*** check to see if this is the last destroy objective completed
	if (level.20mm_weapon1_objective == 1 && level.20mm_weapon2_objective == 1 && level.88mm_weapon_objective == 1)
	{
		level.objective_completed = 3
	}
}

//*** check to see if all the destroy objectives are completed
if (level.20mm_weapon1_objective == 1 && level.20mm_weapon2_objective == 1 && level.88mm_weapon_objective == 1 && level.15cm_weapon_objective == 1)
{
	thread finish_mission
	waitthread global/objectives.scr::current_objectives 4
}

end


//**********************************************************
// finish mission threads based on last objective completed
//**********************************************************
finish_mission:

println "level.objective_completed: " level.objective_completed

switch (level.objective_completed)
{
	case 1:
		//*** player destroyed the flak 30's last
		println "finishing with the flak30s"
		thread finish_flak30
		break

	case 2:
		//*** player destroyed the flak 88 last
		println "finishing with the flak88"
		thread finish_flak88
		break

	case 3:
		//*** player destroyed the 15cm last
		println "finishing with the 15cm"
		thread finish_flak30
		break
}

end


//**********************************************************
// finish thread - flak 30
//**********************************************************
finish_flak30:

waitthread finish_spawn

$finish_captain.origin = $finish_obj1_captain.origin
$finish_engineer.origin = $finish_obj1_engineer.origin
$finish_private1.origin = $finish_obj1_private1.origin
$finish_private2.origin = $finish_obj1_private2.origin

wait 1

$finish_private1 thread takepath $finish_obj1_private1_endpath

wait .1
$finish_private2 thread takepath $finish_obj1_private2_endpath

wait .2
$finish_engineer thread takepath $finish_obj1_engineer_endpath

wait .1
$finish_captain thread takepath $finish_obj1_captain_endpath

wait .1
while ($finish_engineer.ismoving == 1)
{
	wait 1
}

println "engineer made it to the end!"

thread finish_end_sequence
end


//**********************************************************
// finish thread - flak 88
//**********************************************************
finish_flak88:

$finish_obj2_aisay_follow triggerable
$finish_obj2_aisay_cover triggerable

//*** spawn the end allies
waitthread finish_spawn

//*** place them in the right end point
$finish_captain.origin = $finish_obj2_captain.origin
$finish_engineer.origin = $finish_obj2_engineer.origin
$finish_private1.origin = $finish_obj2_private1.origin
$finish_private2.origin = $finish_obj2_private2.origin

wait 1

local.ai_stop_check = 0

$finish_private1 thread takepath $finish_obj2_private1_move1

wait .1
$finish_private2 thread takepath $finish_obj2_private2_move1

wait .2
$finish_engineer thread takepath $finish_obj2_engineer_move1

wait .1
$finish_captain thread takepath $finish_obj2_captain_move1

wait .1
//*** make everybody take cover when they've reached their spots
while (local.ai_stop_check < 4)
{
	if ($finish_private1.ismoving != 1 && $finish_private1.isready != 1)
	{
		$finish_private1 exec global/turnto.scr $finish_obj2_lookpoint1		
//		$finish_private1 exec global/crouch.scr
		$finish_private1 exec global/aimat.scr $finish_german1
		local.ai_stop_check ++
		$finish_private1.isready = 1
	}

	if ($finish_private2.ismoving != 1 && $finish_private2.isready != 1)
	{
		$finish_private2 exec global/turnto.scr $finish_obj2_lookpoint1		
//		$finish_private2 exec global/crouch.scr
		$finish_private2 exec global/aimat.scr $finish_german2
		local.ai_stop_check ++
		$finish_private2.isready = 1
	}

	if ($finish_engineer.ismoving != 1 && $finish_engineer.isready != 1)
	{
		$finish_engineer exec global/turnto.scr $finish_obj2_lookpoint1		
//		$finish_engineer exec global/crouch.scr
		local.ai_stop_check ++
		$finish_engineer.isready = 1
	}

	if ($finish_captain.ismoving != 1 && $finish_captain.isready != 1)
	{
		$finish_captain exec global/turnto.scr $finish_obj2_lookpoint1		
//		$finish_captain exec global/crouch.scr
		$finish_captain exec global/aimat.scr $finish_german3
		local.ai_stop_check ++
		$finish_captain.isready = 1
	}
	
	wait 1
}

//*** make the allied guys take pot shots at the germans
while ($finish_captain.isready == 1)
{
	$finish_private1 thread ai_shoot_volley
	$finish_private2 thread ai_shoot_volley
	//$finish_engineer thread ai_shoot_volley
	$finish_captain thread ai_shoot_volley
	
	wait 4
}



//*** move out after firefight
//$finish_engineer exec global/stand.scr 
$finish_engineer thread takepath $finish_obj2_engineer_move2

wait 1
//$finish_private2 exec global/stand.scr
$finish_private2 thread takepath $finish_obj2_private2_move2

wait .5
//$finish_private1 exec global/stand.scr
$finish_private1 thread takepath $finish_obj2_private1_move2

wait .3
//$finish_captain exec global/stand.scr
$finish_captain thread takepath $finish_obj2_captain_move2

//*** wait for the engineer to show up to signal the end
wait .1
while ($finish_engineer.ismoving == 1)
{
	wait 1
}

println "engineer made it to the end!"

//*** start the end sequence
thread finish_end_sequence
end


//**********************************************
// finish thread - flak88 - AI calls the player
finish_obj2_callplayer:

$finish_private2 say streamed_dfr_scripted_M3L1_086e

wait 3
//$finish_captain anim actor_m3l1_73 //FIX ME needs to be head only, or have a head one
centerprint "AI CAPTAIN YELLS - POWELL GET OVER HERE!!!!"

end


//*********************************************
// finish thread - flak88 - AI says take cover
finish_obj2_cover:

local.ai_stop_check = 0
waitthread finish_german_spawn

thread finish_german_obj2_death

//*** place them in the right end point
$finish_german1.origin = $finish_obj2_german1.origin
$finish_german2.origin = $finish_obj2_german2.origin
$finish_german3.origin = $finish_obj2_german3.origin
$finish_german4.origin = $finish_obj2_german4.origin

$finish_german1 thread takepath $finish_obj2_german1_path
$finish_german2 thread takepath $finish_obj2_german2_path
$finish_german3 thread takepath $finish_obj2_german3_path
$finish_german4 thread takepath $finish_obj2_german4_path

wait 1
//$finish_private2 say dfr_scripted_M3L1_010 //FIX ME needs animation
centerprint "AI YELLS - TAKE COVER!!!!"

//*** make everybody take cover when they've reached their spots
while (local.ai_stop_check < 4)
{
	if ($finish_german1.ismoving != 1 && $finish_german1.isready != 1)
	{
		$finish_german1 exec global/turnto.scr $player		
		$finish_german1 exec global/crouch.scr
		local.ai_stop_check ++
		$finish_german1.isready = 1
		$finish_german1 exec global/enable_ai.scr
		$finish_german1 leash 8
	}

	if ($finish_german2.ismoving != 1 && $finish_german2.isready != 1)
	{
		$finish_german2 exec global/turnto.scr $player		
		$finish_german2 exec global/crouch.scr
		local.ai_stop_check ++
		$finish_german2.isready = 1
		$finish_german2 exec global/enable_ai.scr
		$finish_german2 leash 8
	}

	if ($finish_german3.ismoving != 1 && $finish_german3.isready != 1)
	{
		$finish_german3 exec global/turnto.scr $player		
		$finish_german3 exec global/crouch.scr
		local.ai_stop_check ++
		$finish_german3.isready = 1
		$finish_german3 exec global/enable_ai.scr
		$finish_german3 leash 8
	}

	if ($finish_german4.ismoving != 1 && $finish_german4.isready != 1)
	{
		$finish_german4 exec global/turnto.scr $player		
		$finish_german4 exec global/crouch.scr
		local.ai_stop_check ++
		$finish_german4.isready = 1
		$finish_german4 exec global/enable_ai.scr
		$finish_german4 leash 8
	}
	
	wait 1
}

end


//**********************************************************
// finish end german obj2 death
//**********************************************************
finish_german_obj2_death:

local.loop = 0

while (local.loop != 1)
{
	if (isalive $finish_german1)
	{
		wait 1
	}
	else 	if (isalive $finish_german2)
	{
		wait 1
	}
	else 	if (isalive $finish_german3)
	{
		wait 1
	}
	else 	if (isalive $finish_german4)
	{
		wait 1
	}
	else
	{
		local.loop = 1
		$finish_private1.isready = 0
		$finish_private2.isready = 0
		$finish_engineer.isready = 0
		$finish_captain.isready = 0
	}
}

end


//**********************************************************
// finish end sequence
//**********************************************************
finish_end_sequence:

$finish_trigger triggerable
$finish_trigger waittill trigger

$finish_private1 lookat $finish_captain
$finish_private2 lookat $finish_captain
$finish_engineer lookat $finish_captain
$finish_captain lookat $finish_private1

wait .5
$finish_captain pointat $finish_roadblock_before
$finish_private2 say streamed_dfr_scripted_M3L1_111h
//$finish_captain waittill saydone

wait 3
$finish_captain pointat NULL

$finish_private1 lookat NULL
$finish_private2 lookat NULL
$finish_engineer lookat NULL
$finish_captain lookat NULL

$finish_private1 thread takepath $finish_move_private1

wait .2
$finish_private2 thread takepath $finish_move_private2

wait .1
$finish_captain thread takepath $finish_move_captain

wait .75
$finish_engineer thread takepath $finish_engineer_roadblock_path_in


wait 2
$finish_private1 exec global/turnto.scr $finish_roadblock_before
$finish_private2 exec global/turnto.scr $finish_roadblock_before
$finish_captain exec global/turnto.scr $finish_roadblock_before

while ($finish_engineer.ismoving == 1)
{
	wait 1
}

$finish_engineer exec global/turnto.scr $finish_roadblock_explosives1
$finish_engineer anim set_detpack

wait 1.25
$finish_roadblock_explosives1 show
$finish_engineer waittill animdone

$finish_engineer thread takepath $finish_engineer_roadblock_det2

while ($finish_engineer.ismoving == 1)
{
	wait 1
}

$finish_engineer exec global/turnto.scr $finish_roadblock_explosives2
$finish_engineer anim set_detpack

wait 1.25
$finish_roadblock_explosives2 show
$finish_engineer waittill animdone


$finish_engineer thread takepath $finish_engineer_roadblock_path_out
//$finish_engineer say head_dfr_amb_M1L1_082  //FIX ME - dialog doesn't play
$finish_engineer say dfr_scripted_M3L1_090

wait 1
$finish_private1 exec global/crouch.scr

wait .2
$finish_private2 exec global/crouch.scr

wait .4
$finish_captain exec global/crouch.scr

while ($finish_engineer.ismoving == 1)
{
	wait 1
}

$finish_engineer exec global/crouch.scr

//*** blow up the roadblock - exploder 1
$finish_roadblock_exploder1 anim start
$finish_roadblock_exploder2 anim start
$finish_roadblock_debris1 anim start
thread jitter_large

$finish_roadblock_explosives1 remove

//*** check to see if the player is near the explosion
if ((vector_length ($finish_roadblock_exploder1.origin - $player.origin)) < 256)
{
	$player exec global/bullethit.scr (0 0 250) 500 25 1
}
else if ((vector_length ($finish_roadblock_exploder1.origin - $player.origin)) < 448)
{
	$player exec global/bullethit.scr (0 0 250) 40 25 1
}

//*** blow up the roadblock - exploder 2
wait .5
$finish_roadblock_exploder3 anim start
$finish_roadblock_exploder4 anim start
$finish_roadblock_debris2 anim start
thread jitter_large

$finish_roadblock_after show

$finish_roadblock_explosives2 remove
$finish_roadblock_before remove

//*** check to see if the player is near the explosion
if ((vector_length ($finish_roadblock_exploder3.origin - $player.origin)) < 256)
{
	$player exec global/bullethit.scr (0 0 250) 500 25 1
}
else if ((vector_length ($finish_roadblock_exploder3.origin - $player.origin)) < 448)
{
	$player exec global/bullethit.scr (0 0 250) 40 25 1
}

//*** make the end level trigger triggerable
$finish_endlevel triggerable

//*** move the guys to the rendevous point
$finish_private1 thread takepath $finish_endmove_private1

wait .1
$finish_private2 thread takepath $finish_endmove_private2

wait .2
$finish_engineer thread takepath $finish_endmove_engineer

wait .1
$finish_captain thread takepath $finish_endmove_captain


$finish_endlevel waittill trigger

waitthread global/objectives.scr::add_objectives 4 3

fadeout 1.5 0 0 0 1
wait 2.4

trigger $change_level_trigger

end


//**********************************************************
// spawn in the 4 finishing guys
//**********************************************************
finish_spawn:
//*** spawn the guys in, set them up
spawn "models/human/dday_ranger_captain" targetname "finish_captain" gun "thompson"
spawn "models/human/dday_engineer" targetname "finish_engineer" gun "colt 45"
spawn "models/human/dday_ranger_private" targetname "finish_private1" gun "m1 garand"
spawn "models/human/dday_ranger_private" targetname "finish_private2" gun "bar"

$finish_captain exec global/disable_ai.scr
$finish_engineer exec global/disable_ai.scr
$finish_private1 exec global/disable_ai.scr
$finish_private2 exec global/disable_ai.scr

//*** setup the captain
$finish_captain type_attack cover
$finish_captain ammo_grenade 2
$finish_captain gren_awareness 20
$finish_captain mindist 384
$finish_captain maxdist 512
$finish_captain health 150

//*** setup the engineer
$finish_engineer type_attack cover
$finish_engineer ammo_grenade 0
$finish_engineer gren_awareness 10
$finish_engineer mindist 384
$finish_engineer maxdist 1024
$finish_engineer health 150

//*** setup the garand private1
$finish_private1 type_attack cover
$finish_private1 ammo_grenade 2
$finish_private1 gren_awareness 10
$finish_private1 mindist 128
$finish_private1 maxdist 384
$finish_private1 health 150

//*** setup the BAR private2
$finish_private2 type_attack turret
$finish_private2 ammo_grenade 0
$finish_private2 gren_awareness 6
$finish_private2 mindist 256
$finish_private2 maxdist 768
$finish_private2 health 150

end


//**********************************************************
// spawn in the 4 finishing german guys for 2 routes
//**********************************************************
finish_german_spawn:

//*** spawn the germans to attack
spawn "models/human/german_wehrmact_nco" targetname "finish_german1"
spawn "models/human/german_wehrmact_soldier" targetname "finish_german2"
spawn "models/human/german_wehrmact_soldier" targetname "finish_german3"
spawn "models/human/german_wehrmact_soldier" targetname "finish_german4"

$finish_german1 exec global/disable_ai.scr
$finish_german2 exec global/disable_ai.scr
$finish_german3 exec global/disable_ai.scr
$finish_german4 exec global/disable_ai.scr

//*** setup german1 - the nco
$finish_german1 gun "mp40"
$finish_german1 type_attack cover
$finish_german1 ammo_grenade 2
$finish_german1 accuracy 7

//*** setup german2 - the soldier
$finish_german2 gun "mauser kar 98k"
$finish_german2 type_attack cover
$finish_german2 ammo_grenade 2
$finish_german2 accuracy 7

//*** setup german3 - the soldier
$finish_german3 gun "mauser kar 98k"
$finish_german3 type_attack cover
$finish_german3 ammo_grenade 2
$finish_german3 accuracy 7

//*** setup german4 - the soldier
$finish_german4 gun "mauser kar 98k"
$finish_german4 type_attack cover
$finish_german4 ammo_grenade 2
$finish_german4 accuracy 7

end


//***************************************************
//  activate the backfield
//***************************************************
mg42_backfield_activate:

$mg42_tobruk1 thread global/mg42_active.scr::mg42

$mg42_tobruk2_1.maxyawoffset = 20
$mg42_tobruk2_2.maxyawoffset = 20
$mg42_tobruk2_1 thread global/mg42_active.scr::mg42
$mg42_tobruk2_2 thread global/mg42_active.scr::mg42

$mg42_tobruk3 thread global/mg42_active.scr::mg42

$mg42_88mm_sandbag1 thread global/mg42_active.scr::mg42
$mg42_88mm_sandbag2 thread global/mg42_active.scr::mg42

//*** start the flakk 88 firing
thread 88mm_weapon_firing

end
*/

//*************************************************************
//*************************************************************
//
// ECOUNTER THREADS
//
//*************************************************************
//*************************************************************

//*********************************************
// starting bunker door
//*********************************************
seq_bunker_entrance:

$weh_sol_bunker_lower_1 exec global/setdeathanim.scr "death_fall_back"
$weh_sol_bunker_lower_1 turnto $player.origin
$weh_sol_bunker_lower_1 say den_scripted_M3L1_09 //There's no way the Americans could be in the bunker!

$door_bunker_entrance_upper notsolid
$door_bunker_entrance_upper time 1

$door_bunker_entrance_upper playsound metal_bunker_door_open
$door_bunker_entrance_upper rotateYdown 90
$door_bunker_entrance_upper move

$weh_sol_bunker_lower_1 waittill saydone

$weh_sol_bunker_lower_1 exec global/enable_ai.scr

end


//*********************************************
// table turn over thread
//*********************************************
seq_flip_table:
//println "FLIP TABLE: starting"
level.bunker_lower_alert = 1

//println "FLIP TABLE: dude 2 says some poop"
$weh_sol_bunker_lower_2 say den_scripted_M3L1_04d  //the perimeter has been breached.....

trigger $weh_sol_bunker_lower_3

//*** relocate the dude closer to the table
println "FLIP TABLE: dude location before move: " $weh_sol_bunker_lower_2.origin

$weh_sol_bunker_lower_2.origin = (1631 -1665 -79)

println "FLIP TABLE: dude location before move: " $weh_sol_bunker_lower_2.origin

//*** run the dude to the table and kick it over
//$weh_sol_bunker_lower_2 exec global/runto.scr $weh_sol_bunker_lower_2_path1
//$weh_sol_bunker_lower_2 waittill movedone
//println "FLIP TABLE: dude2 ran to table"

$weh_sol_bunker_lower_2 anim grenade_kick_scripted
//println "FLIP TABLE: dude2 kick the table"

wait .5

$e2_table playsound table_kickover

$e2_table time 0.3
$e2_table rotateZdown 40
$e2_table waitmove

$e2_table time 0.1
$e2_table rotateZdown 30
$e2_table waitmove

$e2_table time 0.05
$e2_table rotateZdown 10
$e2_table waitmove

$e2_table time 0.01
$e2_table rotateZdown 5
$e2_table waitmove

//*** modify AI paths now that the table is knocked over
//$e2_table disconnect_paths

wait .5


//$weh_sol_bunker_lower_2 exec global/moveto.scr $weh_sol_bunker_lower_2_path2
//$weh_sol_bunker_lower_2 waittill movedone

$weh_sol_bunker_lower_2 leash 64
//$weh_sol_bunker_lower_2 exec global/crouch.scr
$weh_sol_bunker_lower_2.type_attack = "cover"
$weh_sol_bunker_lower_2 exec global/enable_ai.scr

end


//*********************************************
// guy opening hatch
//*********************************************
seq_open_lower_hatch:

$weh_sol_bunker_middle_1 exec global/crouch.scr
$weh_sol_bunker_middle_1 say den_scripted_M3L1_10d  //hurry up and open the damned hatch
$weh_sol_bunker_middle_1 exec global/turnto.scr $weh_sol_bunker_middle_1_lookat.origin

$door_floor_hatch1 time 1.3
$door_floor_hatch1 playsound metal_bunker_hatch_open
$door_floor_hatch1 rotateXup 90
$door_floor_hatch1 move

wait .75
$weh_sol_bunker_middle_1 exec global/stand.scr

/*
wait .4
$weh_sol_bunker_middle_1 anim grenade_kick
*/

wait 1.5

if (isalive $weh_sol_bunker_middle_1)
{
        $weh_sol_bunker_middle_1 exec global/enable_ai.scr
        $weh_sol_bunker_middle_1.health = 100	
}

end


//*********************************************
// guys talking at radio
//*********************************************
seq_bunker_middle_radio:

$weh_sol_bunker_middle_2 say den_scripted_M3L1_08d  //get word to the captain......

wait .5
$weh_sol_bunker_middle_2 exec global/runto.scr $weh_sol_bunker_middle_2_path1


wait .75
//*** enable the officers AI
$weh_off_bunker_middle_1 exec global/enable_ai.scr

$bunker_radio playsound den_scripted_M3L1_11d wait     //wiederstandnesten 72, we're under heavy...
$bunker_radio waittill sounddone

//*** enable the NCO's AI
$weh_sol_bunker_middle_2 exec global/enable_ai.scr

if ($weh_off_bunker_middle_1.thinkstate == idle)
{
	$weh_off_bunker_middle_1 say den_scripted_M3L1_12b  //what are you talking about....
	$weh_off_bunker_middle_1 waittill saydone
}

wait 0.1	
$bunker_radio playsound den_scripted_M3L1_13d wait    //the machineguns are overheating......
$bunker_radio waittill sounddone

if ($weh_sol_bunker_middle_2.thinkstate == idle)
{
	$weh_sol_bunker_middle_2 say den_scripted_M3L1_14d  //I need to speak to the lieutenant colonel.....
	$weh_sol_bunker_middle_2 waittill saydone
}

wait .5
$weh_sol_bunker_middle_2 exec global/runto.scr $player

wait .75
$weh_off_bunker_middle_1 exec global/runto.scr $player

if ($weh_off_bunker_middle_1.thinkstate == idle)
{
	$weh_off_bunker_middle_1 say den_scripted_M3L1_06b  //don't let them get to the gunnery deck....
}

end


//*********************************************
//  activate the guys on the middle floor
//*********************************************
seq_bunker_middle_start:

$weh_sol_bunker_middle_3 exec global/enable_ai.scr
$weh_sol_bunker_middle_4 exec global/enable_ai.scr
$weh_sol_bunker_middle_5 exec global/enable_ai.scr

trigger $weh_sol_bunker_middle_3

end


//*********************************************
//  activate the guys on the upper floor
//*********************************************
seq_bunker_upper_start:

//*** autosave the game
exec global/autosave.scr 1

//*** set the objectives
waitthread global/objectives.scr::add_objectives 2 2 "Eliminate the MG42 machine gunners." $mg42_farbunker_2

//*** activate the mg42s
$mg42_bunker_1 startfiring
$mg42_bunker_2 startfiring

$mg42_middle1 startfiring
$mg42_middle2 startfiring

$mg42_farbunker_1.turnspeed = 1000
$mg42_farbunker_2.turnspeed = 1000
$mg42_farbunker_1 thread global/mg42_active.scr::mg42 10000
$mg42_farbunker_2 thread global/mg42_active.scr::mg42 10000
$mg42_farbunker_1_gunner thread mg42_farbunker_gunner_death
$mg42_farbunker_2_gunner thread mg42_farbunker_gunner_death

//*** run the beach scene
thread beach_scene
thread beach_scene_mortar

wait 1
//$mg42_farbunker_1 thread beach_scene_targeting
//$mg42_farbunker_2 thread beach_scene_targeting

spawn script_model targetname "new_target"
local.target = $(new_target)
local.target model fx/dummy.tik

local.target.health = 1000000
local.target.origin = ( -1197 -3500 128)

println "MG42 FARBUNKER TARGET: farbunker target origin: " local.target.origin
println "MG42 FARBUNKER TARGET: farbunker gun 1 target origin: " $mg42_farbunker_1.origin

$mg42_farbunker_1.setaimtarget = local.target

wait .75
$mg42_farbunker_2.setaimtarget = local.target

//*** activate the troops
$weh_off_bunker_upper_1 exec global/enable_ai.scr
$weh_nco_bunker_upper_1 exec global/enable_ai.scr
$weh_sol_bunker_upper_1 exec global/enable_ai.scr
$weh_sol_bunker_upper_2 exec global/enable_ai.scr

//*** have conversation

if ($weh_off_bunker_upper_1.thinkstate == idle)
{
	$weh_off_bunker_upper_1 say den_scripted_M3L1_01b  //I think they're in the bunker
	$weh_off_bunker_upper_1 waittill saydone
}

wait .75
if ($weh_nco_bunker_upper_1.thinkstate == idle)
{
	$weh_nco_bunker_upper_1 say den_scripted_M3L1_02d  //which floor?
	$weh_nco_bunker_upper_1 waittill saydone
}

wait .75
if ($weh_off_bunker_upper_1.thinkstate == idle)
{
	$weh_off_bunker_upper_1 say den_scripted_M3L1_03b  //I don't know, gather some men.......
	$weh_off_bunker_upper_1 waittill saydone
}

$weh_off_bunker_upper_1 exec global/runto.scr $weh_off_bunker_upper_1_path1
$weh_nco_bunker_upper_1 exec global/runto.scr $weh_nco_bunker_upper_1_path1

wait .5
$weh_sol_bunker_upper_1 exec global/runto.scr $weh_sol_bunker_upper_1_path1

wait .75
$weh_sol_bunker_upper_2 exec global/runto.scr $weh_sol_bunker_upper_2_path1

end


//*********************************************
// guys entering the bunker upon exit
//*********************************************
seq_bunker_upper_exit:

wait 5
level.bunker_exit = 1

$door_bunker_exit_lock remove

$door_bunker_exit time 1
$door_bunker_exit playsound metal_bunker_door_open
$door_bunker_exit rotateyup 90
$door_bunker_exit waitmove

//*** disconnect paths
$door_bunker_exit disconnect_paths

wait .5
$weh_nco_bunker_exit_1 exec global/enable_ai.scr
$weh_sol_bunker_exit_1 exec global/enable_ai.scr
$weh_sol_bunker_exit_2 exec global/enable_ai.scr

$weh_nco_bunker_exit_1.type_idle = "idle"
$weh_sol_bunker_exit_1.type_idle = "idle"
$weh_sol_bunker_exit_2.type_idle = "idle"

$weh_nco_bunker_exit_1.enemysharerange = 16
$weh_sol_bunker_exit_1.enemysharerange = 16
$weh_sol_bunker_exit_2.enemysharerange = 16

$weh_nco_bunker_exit_1 exec global/runto.scr $player
$weh_sol_bunker_exit_1 exec global/runto.scr $player
$weh_sol_bunker_exit_2 exec global/runto.scr $player

//$weh_nco_bunker_exit_1 attackplayer
//$weh_sol_bunker_exit_1 attackplayer
//$weh_sol_bunker_exit_2 attackplayer

$weh_nco_bunker_exit_1 forceactivate
$weh_sol_bunker_exit_1 forceactivate
$weh_sol_bunker_exit_2 forceactivate

end


//*********************************************
// mg42 fodder spawn - bunker_upper
//*********************************************
mg42_bunker_upper_fodder:

if (level.bunker_exit == 1 && $mg42_bunker_upper.isused != 1)
{
	//*** set the variable to denote that this turret has been used once now
	$mg42_bunker_upper.isused = 1
	
	//*** spawn the 4 guys
        spawn "models/human/german_wehrmact_soldier" targetname "mg42_bunker_upper_fodder1" gun "mauser kar 98k"
        spawn "models/human/german_wehrmact_soldier" targetname "mg42_bunker_upper_fodder2" gun "mauser kar 98k"
        spawn "models/human/german_wehrmact_soldier" targetname "mg42_bunker_upper_fodder3" gun "mauser kar 98k"
        spawn "models/human/german_wehrmact_nco" targetname "mg42_bunker_upper_fodder4" gun "mp40"
	spawn "models/human/german_wehrmact_soldier" targetname "mg42_bunker_upper_fodder5" gun "mauser kar 98k"
	spawn "models/human/german_wehrmact_nco" targetname "mg42_bunker_upper_fodder6" gun "mp40"
        
	//*** disable their AI temporarily for transport
        $mg42_bunker_upper_fodder1 exec global/disable_ai.scr
        $mg42_bunker_upper_fodder2 exec global/disable_ai.scr
        $mg42_bunker_upper_fodder3 exec global/disable_ai.scr
        $mg42_bunker_upper_fodder4 exec global/disable_ai.scr
	$mg42_bunker_upper_fodder5 exec global/disable_ai.scr
	$mg42_bunker_upper_fodder6 exec global/disable_ai.scr
        
	//*** start popping the guys in, make them run to player, and activate them
        $mg42_bunker_upper_fodder1.origin = $mg42_bunker_upper_fodder_spawn1.origin
        $mg42_bunker_upper_fodder1 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder1 exec global/runto.scr $player
        
        wait .75
        $mg42_bunker_upper_fodder2.origin = $mg42_bunker_upper_fodder_spawn2.origin
        $mg42_bunker_upper_fodder2 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder2 exec global/runto.scr $player
        
        wait 1
        $mg42_bunker_upper_fodder3.origin = $mg42_bunker_upper_fodder_spawn1.origin
        $mg42_bunker_upper_fodder3 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder3 exec global/runto.scr $player
        
        wait 1
        $mg42_bunker_upper_fodder4.origin = $mg42_bunker_upper_fodder_spawn2.origin
        $mg42_bunker_upper_fodder4 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder4 exec global/runto.scr $player

        wait 1
        $mg42_bunker_upper_fodder5.origin = $mg42_bunker_upper_fodder_spawn1.origin
        $mg42_bunker_upper_fodder5 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder5 exec global/runto.scr $player	
	
        wait 1
        $mg42_bunker_upper_fodder6.origin = $mg42_bunker_upper_fodder_spawn2.origin
        $mg42_bunker_upper_fodder6 exec global/enable_ai.scr
        $mg42_bunker_upper_fodder6 exec global/runto.scr $player	
}

end


//**************************************************
// make some guys retreat when looking out from bunker
//**************************************************
seq_mg42_retreat:

$mg42_middle1_gunner.type_idle = "idle"
$mg42_middle1_gunner.type_attack = "cover"
$mg42_middle1_gunner.type_disguise = "none"
$mg42_middle1_gunner.type_grenade = "grenade"

$mg42_middle2_gunner.type_idle = "idle"
$mg42_middle2_gunner.type_attack = "cover"
$mg42_middle2_gunner.type_disguise = "none"
$mg42_middle2_gunner.type_grenade = "grenade"

//*** make the guys run away
$mg42_middle1_gunner thread seq_mg42_retreat_run 
$mg42_middle2_gunner thread seq_mg42_retreat_run

$weh_nco_retreat_1 thread seq_mg42_retreat_run

wait .75
$weh_sol_retreat_2 thread seq_mg42_retreat_run

wait .5
$weh_sol_retreat_3 thread seq_mg42_retreat_run

end

//*********************************************
// run thread for mg42 retreat sequence
seq_mg42_retreat_run:

local.self exec global/runto.scr $mg42_middle_retreat
local.self waittill movedone

wait 2
local.self remove

end


/*
//*********************************************
// activate the trench guys
//*********************************************
trench_go:

$weh_nco_trench_1 exec global/enable_ai.scr
$weh_sol_trench_2 exec global/enable_ai.scr
$weh_sol_trench_3 exec global/enable_ai.scr
$weh_sol_trench_4 exec global/enable_ai.scr

$weh_nco_trench_1 thread trench_run
$weh_sol_trench_2 thread trench_run
$weh_sol_trench_3 thread trench_run
$weh_sol_trench_4 thread trench_run

end


//*********************************************
// guys run to place then attack player
trench_run:

local.self exec global/runto.scr $trench_node1
local.self waittill movedone

local.self exec global/runto.scr $trench_node2
local.self waittill movedone

local.self attackplayer

end


//*********************************************
// activate the ditch guys
//*********************************************
ditch_go:

//*** make the germans run to their places
$weh_nco_ditch_1 thread ditch_run

wait .2
$weh_nco_ditch_2 thread ditch_run

wait .2
$weh_sol_ditch_3 thread ditch_run

wait .2
$weh_sol_ditch_4 thread ditch_run

wait .2
$weh_sol_ditch_5 thread ditch_run

level.ditch = 0

$weh_nco_ditch_1 thread ditch_enemy_death
$weh_nco_ditch_2 thread ditch_enemy_death
$weh_sol_ditch_3 thread ditch_enemy_death
$weh_sol_ditch_4 thread ditch_enemy_death
$weh_sol_ditch_5 thread ditch_enemy_death

//*** spawn in the friendlies for the assist
spawn "models/human/dday_ranger_captain" targetname "ran_cap_ditch_1" gun "thompson"
spawn "models/human/dday_ranger_sergeant" targetname "ran_ser_ditch_2" gun "m1 garand"
spawn "models/human/dday_ranger_private" targetname "ran_pri_ditch_3" gun "m1 garand"
spawn "models/human/dday_ranger_private" targetname "ran_pri_ditch_4" gun "bar"

//*** position and setup the friendlies
$ran_cap_ditch_1.type_attack = "cover"
$ran_ser_ditch_2.type_attack = "cover"
$ran_pri_ditch_3.type_attack = "cover"
$ran_pri_ditch_4.type_attack = "cover"

$ran_cap_ditch_1.maxdist = 1700
$ran_ser_ditch_2.maxdist = 1700
$ran_pri_ditch_3.maxdist = 1700
$ran_pri_ditch_4.maxdist = 1700

$ran_cap_ditch_1 exec global/disable_ai.scr
$ran_ser_ditch_2 exec global/disable_ai.scr
$ran_pri_ditch_3 exec global/disable_ai.scr
$ran_pri_ditch_4 exec global/disable_ai.scr

$ran_cap_ditch_1.origin = ( -72.00 -928.00 256.00)
$ran_ser_ditch_2.origin = (8.00 -840.00 256.00)
$ran_pri_ditch_3.origin = ( -16.00 -912.00 256.00)
$ran_pri_ditch_4.origin = (64.00 -816.00 256.00)

$ran_cap_ditch_1.health = 10000
$ran_ser_ditch_2.health = 10000

wait 3
//*** enable the ai
$weh_nco_ditch_1 exec global/enable_ai.scr
$weh_nco_ditch_2 exec global/enable_ai.scr
$weh_sol_ditch_3 exec global/enable_ai.scr
$weh_sol_ditch_4 exec global/enable_ai.scr
$weh_sol_ditch_5 exec global/enable_ai.scr

//*** make the allies run to the location
$ran_cap_ditch_1 thread ditch_run
$ran_ser_ditch_2 thread ditch_run
$ran_pri_ditch_3 thread ditch_run
$ran_pri_ditch_4 thread ditch_run

wait 4
$ran_cap_ditch_1 exec global/enable_ai.scr
$ran_ser_ditch_2 exec global/enable_ai.scr
$ran_pri_ditch_3 exec global/enable_ai.scr
$ran_pri_ditch_4 exec global/enable_ai.scr

end


//*********************************************
// guys run to place
ditch_run:

local.node = $(local.self.targetname + "_node")

local.self exec global/runto.scr local.node

end


//*********************************************
// enemy death threads to tell when their all dead
ditch_enemy_death:

local.self waittill death

level.ditch ++

if (level.ditch == 5)
{
	//*** when all the enemies are dead, tell the player to go for the 20mm
	thread ditch_done
}

end


//*********************************************
// all the ditch guys are dead, next sequence
ditch_done:

//*** move the captain to the sergeant
$ran_cap_ditch_1.movedoneradius = 128
$ran_cap_ditch_1 exec global/runto.scr $ran_ser_ditch_2
$ran_cap_ditch_1 waittill movedone

$ran_cap_ditch_1 lookat $ran_ser_ditch_2

wait .3
$ran_ser_ditch_2 lookat $ran_cap_ditch_1


$ran_cap_ditch_1 say streamed_dfr_scripted_M3L1_109d  //20mils, let's take 'em out
$ran_cap_ditch_1 waittill saydone

$ran_cap_ditch_1.health = 100
$ran_ser_ditch_2.health = 100

if (isalive $ran_pri_ditch_3)
{
	$ran_pri_ditch_3.health = 100
}

if (isalive $ran_pri_ditch_4)
{
	$ran_pri_ditch_4.health = 100
}

//*** move them forward to get killed
$ran_cap_ditch_1 thread ditch2_run
$ran_ser_ditch_2 thread ditch2_run

if (isalive $ran_pri_ditch_3)
{
	$ran_pri_ditch_3 thread ditch2_run
}

if (isalive $ran_pri_ditch_4)
{
	$ran_pri_ditch_4 thread ditch2_run
}

wait 4
thread ditch2_tobruk3_target
thread ditch2_tobruk2_1_target

end


//*********************************************
// guys run to place for ditch2
ditch2_run:

local.node = $(local.self.targetname + "_node2")

local.self exec global/runto.scr local.node

end


//*********************************************
// captain says to pin those tobruks
ditch2_say:

$ran_cap_ditch_1 say streamed_dfr_scripted_M3L1_110f  //pin those tobrukst

end


//*********************************************
// targeting for tobruk3 mg42
ditch2_tobruk3_target:

while (isalive $ran_pri_ditch_3)
{
	$mg42_tobruk3.setaimtarget = $ran_pri_ditch_3
}

while (isalive $ran_ser_ditch_2)
{
	$mg42_tobruk3.setaimtarget = $ran_ser_ditch_2
}

end


//*********************************************
// targeting for tobruk2_1 mg42
ditch2_tobruk2_1_target:

while (isalive $ran_pri_ditch_4)
{
	$mg42_tobruk3.setaimtarget = $ran_pri_ditch_4
}

while (isalive $ran_cap_ditch_1)
{
	$mg42_tobruk3.setaimtarget = $ran_cap_ditch_1
}

end


//*********************************************
// activate the flakk 88 guys
//*********************************************
88mm_weapon_gunnery_activate:

$88mm_weapon_gunnery_operator exec global/enable_ai.scr
$88mm_weapon_gunnery_commander exec global/enable_ai.scr

$88mm_weapon_gunnery_operator unholster
$88mm_weapon_gunnery_commander unholster

$88mm_weapon_gunnery_operator health 100
$88mm_weapon_gunnery_commander health 100

$88mm_weapon_gunnery_operator attackplayer
$88mm_weapon_gunnery_commander attackplayer

end

*/


//*************************************************************
//*************************************************************
//
// AI THREADS
// naming convenction for AI is
// e (encounter) # (number of the encounter) x (seperator) # (number of guy in that encounter)
//
//*************************************************************
//*************************************************************

//*********************************************
// setup the ambient allied beach scene guys
//*********************************************
ai_allied_beach_setup:

local.self exec global/disable_ai.scr

//*** set target eligibility
local.self.istarget = 0

local.self thread ai_allied_beach_death

end


//*********************************************
// ambient allied beach scene guys death thread
//*********************************************
ai_allied_beach_death:

//*** waittill death
local.self waittill death

local.self weapon_internal ""

//*** reset the targetname so another can spawn
local.self.targetname = NULL

end


//*********************************************
// ambient allied beach scene guys takepath routine
//*********************************************
ai_allied_beach_takepath local.index:

local.self exec global/runto.scr $allied_beach_path[$allied_beach_spawn[local.index].path_index]
local.self waittill movedone

local.self remove

end


//*********************************************
// upper officer alarm thread
//*********************************************
weh_off_bunker_upper_1_alarm:

$mg42_bunker_1_gunner.type_idle = "idle"
$mg42_bunker_1_gunner.type_attack = "cover"
$mg42_bunker_1_gunner.type_grenade = "grenade"
$mg42_bunker_1_gunner.type_disguise = "none"
$mg42_bunker_1_gunner.weapon = "mp40"

$mg42_bunker_2_gunner.type_idle = "idle"
$mg42_bunker_2_gunner.type_attack = "cover"
$mg42_bunker_2_gunner.type_grenade = "grenade"
$mg42_bunker_2_gunner.type_disguise = "none"
$mg42_bunker_2_gunner.weapon = "mauser kar 98k"

$mg42_bunker_1_gunner unholster
$mg42_bunker_2_gunner unholster

$mg42_bunker_1_gunner attackplayer
$mg42_bunker_2_gunner attackplayer

end


//*********************************************
// upper officer pain thread
//*********************************************
weh_off_bunker_upper_1_pain:

local.self waittill pain

if ($player.progress == "bunker_deck")
{
        $mg42_bunker_1_gunner.type_idle = "idle"
        $mg42_bunker_1_gunner.type_attack = "cover"
        $mg42_bunker_1_gunner.type_grenade = "grenade"
        $mg42_bunker_1_gunner.type_disguise = "none"
	$mg42_bunker_1_gunner.weapon = "mp40"
        
        $mg42_bunker_2_gunner.type_idle = "idle"
        $mg42_bunker_2_gunner.type_attack = "cover"
        $mg42_bunker_2_gunner.type_grenade = "grenade"
        $mg42_bunker_2_gunner.type_disguise = "none"
	$mg42_bunker_2_gunner.weapon = "mauser kar 98k"
        
        $mg42_bunker_1_gunner unholster
        $mg42_bunker_2_gunner unholster
        
        $mg42_bunker_1_gunner attackplayer
        $mg42_bunker_2_gunner attackplayer
}

end


//*********************************************
// mg42 bunker 1 gunner pain thread
//*********************************************
mg42_bunker_1_gunner_pain:

local.self waittill pain

$mg42_bunker_1_gunner.type_idle = "idle"
$mg42_bunker_1_gunner.type_attack = "cover"
$mg42_bunker_1_gunner.type_grenade = "grenade"
$mg42_bunker_1_gunner.type_disguise = "none"
$mg42_bunker_1_gunner.weapon = "mp40"

$mg42_bunker_2_gunner.type_idle = "idle"
$mg42_bunker_2_gunner.type_attack = "cover"
$mg42_bunker_2_gunner.type_grenade = "grenade"
$mg42_bunker_2_gunner.type_disguise = "none"
$mg42_bunker_2_gunner.weapon = "mauser kar 98k"

$mg42_bunker_1_gunner unholster
$mg42_bunker_2_gunner unholster

$mg42_bunker_1_gunner attackplayer
$mg42_bunker_2_gunner attackplayer

end


//*********************************************
// mg42 bunker 1 gunner death thread
//*********************************************
mg42_bunker_1_gunner_death:

local.self waittill death

if !(isalive $mg42_bunker_2_gunner)
{
	//*** TEMP TEMP TEMP POOPHEAD ENDING
	//thread seq_bunker_upper_exit
}

end


//*********************************************
// mg42 bunker 2 gunner pain thread
//*********************************************
mg42_bunker_2_gunner_pain:

local.self waittill pain

$mg42_bunker_1_gunner.type_idle = "idle"
$mg42_bunker_1_gunner.type_attack = "cover"
$mg42_bunker_1_gunner.type_grenade = "grenade"
$mg42_bunker_1_gunner.type_disguise = "none"
$mg42_bunker_1_gunner.weapon = "mp40"

$mg42_bunker_2_gunner.type_idle = "idle"
$mg42_bunker_2_gunner.type_attack = "cover"
$mg42_bunker_2_gunner.type_grenade = "grenade"
$mg42_bunker_2_gunner.type_disguise = "none"
$mg42_bunker_2_gunner.weapon = "mauser kar 98k"

$mg42_bunker_1_gunner unholster
$mg42_bunker_2_gunner unholster

$mg42_bunker_1_gunner attackplayer
$mg42_bunker_2_gunner attackplayer

end


//*********************************************
// mg42 bunker 2 gunner death thread
//*********************************************
mg42_bunker_2_gunner_death:

local.self waittill death

if !(isalive $mg42_bunker_1_gunner)
{
	//*** TEMP TEMP TEMP POOPHEAD ENDING
	//thread seq_bunker_upper_exit
}

end


//*********************************************
// starting bunker door on lower level guy death
//*********************************************
weh_sol_bunker_lower_1_death:

local.self waittill death

wait .75
if (level.bunker_lower_alert != 1)
{
	$weh_sol_bunker_lower_2 say den_scripted_M3L1_01b
}

end


//*********************************************
// lower level guys death thread
//*********************************************
weh_sol_bunker_lower_2_death:

local.self waittill death

//*** wake up the guys in the next room

$weh_sol_bunker_lower_4 exec global/enable_ai.scr
$weh_sol_bunker_lower_5 exec global/enable_ai.scr

trigger $weh_sol_bunker_lower_4
trigger $weh_sol_bunker_lower_5

wait 2
$weh_sol_bunker_lower_4 attackplayer
$weh_sol_bunker_lower_5 attackplayer

end


//*********************************************
// lower level guys death thread
//*********************************************
weh_sol_bunker_lower_3_death:

local.self waittill death

//*** wake up the guys in the next room
$weh_sol_bunker_lower_4 exec global/enable_ai.scr
$weh_sol_bunker_lower_5 exec global/enable_ai.scr

trigger $weh_sol_bunker_lower_4
trigger $weh_sol_bunker_lower_5

wait 2
$weh_sol_bunker_lower_4 attackplayer
$weh_sol_bunker_lower_5 attackplayer

end


//*********************************************
// death thread for the upper bunker for objective
//********************************************
upper_bunker_death:

local.self waittill death

//*** increment the counter for the objective
level.clear_bunker ++

//*** run the thread to check for the objective completion
thread clear_bunker_objective

end


//*********************************************
// death thread for the upper bunker for objective
//********************************************
mg42_farbunker_gunner_death:

local.self waittill death

//*** increment the counter for the objective
level.clear_farbunker_gunner ++

//*** run the thread to check for the objective completion
thread clear_farbunker_gunner_objective

end


//*************************************************************
//*************************************************************
//
// FUNCTION THREADS
//
//*************************************************************
//*************************************************************

//*********************************************
// take path, to tell an AI to take a path
// $targetname takepath <name of path> <movement method|walk - walks, default is run>
//*********************************************
takepath local.path local.movement:

if (local.self.ismoving == 1)
{
	println local.self " is already moving, aborting takepath!"
	goto takepath_ismoving_end
}

local.self.ismoving = 1

switch (local.movement)
{
	case "walk":
		println ("XXX " + local.self.targetname + " start walking on path " + local.path")
		local.self exec global/walkto.scr local.path
		local.self waittill movedone
		break

	default:
		println ("XXX " + local.self.targetname + " start running on path " + local.path)
		local.self exec global/runto.scr local.path
		local.self waittill movedone
		break
}


local.self.ismoving = 0

takepath_ismoving_end:
end


//*************************************************************
// move object
// move_object <distance to move to|vector> <time to take>
//*************************************************************
move_object local.distance local.time:

//*** calculate how many moves it will have to make based on once/server frame
local.index = local.time / .05

//*** calculate the distance per move per axis
local.move_distance_x = local.distance[0] / local.index
local.move_distance_y = local.distance[1] / local.index
local.move_distance_z = local.distance[2] / local.index

//*** move the object every sever frame
for (local.i = 0 ; local.i <= local.time ; local.i += .05)
{
	local.newx = local.self.origin[0] + local.move_distance_x
	local.newy = local.self.origin[1] + local.move_distance_y
	local.newz = local.self.origin[2] + local.move_distance_z

	//*** set the new origin
	local.self.origin = (local.newx local.newy local.newz)
	
	waitframe
}

end


//******************************************************************************
// shooting routine for the AI
// <$targetname_of_ai> ai_shoot_volley <target to aim at> [optional crouch when done]
//******************************************************************************
ai_shoot_volley local.target local.crouch:

//*** if he's dead, quit out
if !(isalive local.self)
{
	goto ai_shoot_volley_end
}

//*** make the ai stand up
local.self exec global/stand.scr

//*** set variable to tell that this guy is shooting a volley
local.shots = ((randomint 3) + 5)
local.self exec global/aimat.scr local.target

wait .5
for (local.i = 1 ; local.i <= local.shots ; local.i ++)
{
        local.self exec global/shoot.scr
        wait (randomfloat .3 + .15)
}

local.self exec global/aimat.scr NULL

if (local.crouch != NIL)
{
	local.self exec global/crouch.scr
}

ai_shoot_volley_end:
end


//*************************************************************
// killing an AI with gunfire
// <$targetname_of_ai> ai_mg_death
//*************************************************************
ai_mg_death:

if !(isalive local.self)
{
	goto ai_mg_death_end
}

//*** set variable to tell that this guy is shooting a volley
local.shots = ((randomint 2) + 2)

for (local.i = 1 ; local.i <= local.shots ; local.i ++)
{
	local.self thread bhit 20 -1
	wait (randomfloat .3 + .15)
}

local.self thread bhit 1000 -1

ai_mg_death_end:
end


//*************************************************************
// killing an AI with mortar
// <$targetname_of_ai> ai_mortar_death [water, mine | default dirt]
//*************************************************************
ai_mortar_death local.type:

if !(isalive local.self)
{
	goto ai_mortar_death_end
}

//*** set the guys death animation
local.self exec global/setdeathanim.scr death_mortar

//*** set the type of mortar
if (local.type == "water")
{
	local.spawn_type = "models/animate/fx_mortar_water"
}
else if (local.type == "mine")
{
	local.spawn_type = "models/animate/fx_explosion_mine"
}
else
{
	local.spawn_type = "models/animate/fx_mortar_dirt"
}

//*** set the origin and targetname
local.spawn_origin = local.self.origin
local.spawn_origin[2] += 32
local.spawn_mortar = (local.self.targetname + "_mortar")

//*** spawn the item
spawn local.spawn_type targetname local.spawn_mortar
local.spawn_mortar = $(local.self.targetname + "_mortar")

//*** reset the items origin
local.spawn_mortar.origin = local.spawn_origin

//*** call the mortar
local.spawn_mortar waitthread mortar_call 1

wait 2
local.spawn_mortar remove

ai_mortar_death_end:
end


//*****************************************************
//  mortar call in
// <mortar> mortar_call [play leadin sound| any value for no]
//*****************************************************
mortar_call local.leadin:

if (local.leadin == NIL)
{
	$player playsound arty_leadin wait
	$player waittill sounddone
}

local.self anim start

//check the distance to the player, if he's close, use the greater jitter
local.distance = vector_length (local.self.origin - $player.origin)

if (local.distance >= 513) //*** beyond 512, small shake
{
	thread jitter_small
}
else if (local.distance >= 193) //*** between 193 and 512, medium shake
{
	thread jitter_medium
}
else if (local.distance >= 97) //*** between 97 and 192, large jitter, hurt the player if he's not in cover
{
	thread jitter_large
	/*
	if ($player.cover_index == 0)
	{
		$player thread bhit 100
	}
	*/
}
else //*** under 97, large jitter, kill the player regardless of cover
{
	thread jitter_large
	/*
	$player thread bhit 5000
	*/
}

radiusdamage local.self.origin 1000 192

end


//**************************************************************************************************************************************
//  bullet hit command
//  <target> bhit [damage| 40 default] [body location| default is chest, -1 is random] [direction| vector] [force to apply| 15 default]
//**************************************************************************************************************************************
bhit local.damage local.location local.direction local.force:

if (local.damage == NIL || local.damage == 0)
{
	local.damage = 40
}

if (local.location == NIL)
{
	local.location = 3
}
else if (local.location == -1)
{
	local.temp = (randomint 17 + 1)
	local.location = local.temp
}

if (local.direction == NIL || local.direction == 0)
{
	local.direction = (0 -1 0)
}

if (local.force == NIL)
{
	local.force = 15
}

//*** set the characters script_damage variable so the player doesn't lose the level
local.self.script_damage = 1

//*** damage the target
local.self exec global/bullethit.scr local.direction local.damage local.force local.location

local.self playsound snd_bh_flesh

local.self.script_damage = 0

end


//******************************
// jitter effect from mgs
// jitter_mg [delay]
//******************************
jitter_mg local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .5 1 0 0

waitexec global/earthquake.scr .3 1 0 0

end


//*********************************
// jitter effect from mgs in cover
// jitter_mg_cover [delay]
//*********************************
jitter_mg_cover local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .3 .5 0 0

waitexec global/earthquake.scr .3 .2 0 0

end


//*********************************
// jitter effect from mgs in cover
// jitter_small [delay]
//*********************************
jitter_small local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .3 1 0 0

waitexec global/earthquake.scr .3 .75 0 0

waitexec global/earthquake.scr 1.25 .3 0 0

end


//******************************
// jitter medium effect
// jitter_medium [delay]
//******************************
jitter_medium local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .23 2 0 0

waitexec global/earthquake.scr 1 1 0 0

waitexec global/earthquake.scr 1.25 .3 0 1

end


//******************************
// jitter large effect
// jitter_large [delay]
//******************************
jitter_large local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .25 3 0 0

waitexec global/earthquake.scr .4 1.25 0 0

waitexec global/earthquake.scr 1 .75 0 0

waitexec global/earthquake.scr 1.25 .3 0 1

end


//********************************************
// jitter effect from being next to artillery
// jitter_artillery [delay]
//********************************************
jitter_artillery local.time:

if (local.time)
{
	wait local.time
}

waitexec global/earthquake.scr .23 3 0 0

//waitexec global/earthquake.scr .3 .5 0 0

end


//********************************************
// huddraw refresh thread
//********************************************
huddrawrefresh:

println "NEED HUDDRAW REFRESH!!"

end

